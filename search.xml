<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome</title>
    <url>/2023/03/12/00-04-39/</url>
    <content><![CDATA[<h2 id="Welcome-to-My-Blog"><a href="#Welcome-to-My-Blog" class="headerlink" title="Welcome to My Blog"></a>Welcome to My Blog</h2>]]></content>
  </entry>
  <entry>
    <title>P3设计文档</title>
    <url>/2023/03/10/19-16-32/</url>
    <content><![CDATA[<h2 id="P3设计文档"><a href="#P3设计文档" class="headerlink" title="P3设计文档"></a>P3设计文档</h2><span id="more"></span>

<h2 id="CPU流程，草稿"><a href="#CPU流程，草稿" class="headerlink" title="CPU流程，草稿"></a>CPU流程，草稿</h2><ol>
<li>取指令(PC,IM)</li>
<li>指令译码(CU)</li>
<li>指令执行(GRF,ALU)</li>
<li>储存器访问(DM)</li>
<li>结果写回(GRF)</li>
<li>循环1-5</li>
</ol>
<h3 id="支持指令"><a href="#支持指令" class="headerlink" title="支持指令"></a>支持指令</h3><p>add, sub, ori, lw, sw, beq, lui, j, nop</p>
<p>(其中add，sub为无符号加减法)</p>
<h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><h4 id="一、IFU（Instruction-Fetch-Unit）"><a href="#一、IFU（Instruction-Fetch-Unit）" class="headerlink" title="一、IFU（Instruction Fetch Unit）"></a>一、IFU（Instruction Fetch Unit）</h4><ul>
<li><p>包括PC和IM</p>
</li>
<li><p>IM用 ROM 实现，容量为 32bit × 32字。（5位地址）</p>
</li>
<li><p>PC始终为4的倍数（字节寻址，32bit&#x3D;4字节），所以取32位地址中2-6位对应ROM中指令地址</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>端口名</th>
<th>输入&#x2F;输出</th>
<th>位宽</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>in</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>in</td>
<td>1</td>
<td>异步复位</td>
</tr>
<tr>
<td>PCSrc</td>
<td>in</td>
<td>1</td>
<td>下一指令地址选择信号</td>
</tr>
<tr>
<td>Jump</td>
<td>in</td>
<td>1</td>
<td>跳转控制信号</td>
</tr>
<tr>
<td>shiftResult</td>
<td>in</td>
<td>32</td>
<td>偏移后的指令地址</td>
</tr>
<tr>
<td>jumpAdd</td>
<td>in</td>
<td>32</td>
<td>直接跳转的指令地址</td>
</tr>
<tr>
<td>D</td>
<td>out</td>
<td>32</td>
<td>输出读取指令</td>
</tr>
</tbody></table>
<h4 id="三、GRF（General-Register-File）"><a href="#三、GRF（General-Register-File）" class="headerlink" title="三、GRF（General Register File）"></a>三、GRF（General Register File）</h4><ul>
<li>存储$0~$31这32个寄存器数据</li>
<li>具有异步复位，读、写功能</li>
<li>最多一次同时取出两个寄存器的值运算，存入一个寄存器的值</li>
<li>$0寄存器输入为常数0</li>
</ul>
<table>
<thead>
<tr>
<th>端口名</th>
<th>输入&#x2F;输出</th>
<th>位宽</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>in</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>in</td>
<td>1</td>
<td>异步复位</td>
</tr>
<tr>
<td>WE</td>
<td>in</td>
<td>1</td>
<td>写入使能信号</td>
</tr>
<tr>
<td>A1</td>
<td>in</td>
<td>5</td>
<td>输出数据到RD1的寄存器的地址</td>
</tr>
<tr>
<td>A2</td>
<td>in</td>
<td>5</td>
<td>输出数据到RD2的寄存器的地址</td>
</tr>
<tr>
<td>WA</td>
<td>in</td>
<td>5</td>
<td>输入到寄存器的地址</td>
</tr>
<tr>
<td>WD</td>
<td>in</td>
<td>32</td>
<td>写入的数据</td>
</tr>
<tr>
<td>RD1</td>
<td>out</td>
<td>32</td>
<td>RD1输出的数据</td>
</tr>
<tr>
<td>RD2</td>
<td>out</td>
<td>32</td>
<td>RD2输出的数据</td>
</tr>
</tbody></table>
<h4 id="四、ALU（Arithmetic-amp-logical-Unit）"><a href="#四、ALU（Arithmetic-amp-logical-Unit）" class="headerlink" title="四、ALU（Arithmetic &amp; logical Unit）"></a>四、ALU（Arithmetic &amp; logical Unit）</h4><ul>
<li><p>提供 32 位加、减、或运算及大小比较功能，</p>
</li>
<li><p>加减法按无符号处理</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>端口名</th>
<th>输入&#x2F;输出</th>
<th>位宽</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>op</td>
<td>in</td>
<td>3</td>
<td>ALU功能控制信号 000：加，001：减，010：或，比较：任意</td>
</tr>
<tr>
<td>A</td>
<td>in</td>
<td>32</td>
<td>输入1</td>
</tr>
<tr>
<td>B</td>
<td>in</td>
<td>32</td>
<td>输入2</td>
</tr>
<tr>
<td>Y</td>
<td>out</td>
<td>32</td>
<td>输出</td>
</tr>
<tr>
<td>Greater</td>
<td>out</td>
<td>1</td>
<td>A&gt;B</td>
</tr>
<tr>
<td>Equal</td>
<td>out</td>
<td>1</td>
<td>A&#x3D;B</td>
</tr>
<tr>
<td>Less</td>
<td>out</td>
<td>1</td>
<td>A&lt;B</td>
</tr>
</tbody></table>
<h4 id="五、DM（Data-Memory）"><a href="#五、DM（Data-Memory）" class="headerlink" title="五、DM（Data Memory）"></a>五、DM（Data Memory）</h4><ul>
<li>使用 RAM 实现，有<strong>异步复位</strong>功能，复位值为 0x00000000。容量为 32bit × 32字（5位地址），使用双端口模式</li>
<li>地址始终为4的倍数（lw&#x2F;rw每次操作一个字&#x3D;4字节），所以取32位地址中2-6位对应RAM地址，对于lb&#x2F;rb等指令还需更改</li>
</ul>
<table>
<thead>
<tr>
<th>端口名</th>
<th>输入&#x2F;输出</th>
<th>位宽</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>in</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>in</td>
<td>1</td>
<td>异步复位</td>
</tr>
<tr>
<td>WE</td>
<td>in</td>
<td>1</td>
<td>写入使能信号</td>
</tr>
<tr>
<td>A</td>
<td>in</td>
<td>5</td>
<td>将要读&#x2F;写的寄存器的地址</td>
</tr>
<tr>
<td>WD</td>
<td>in</td>
<td>32</td>
<td>写入的数据</td>
</tr>
<tr>
<td>RD</td>
<td>out</td>
<td>32</td>
<td>读出的数据</td>
</tr>
</tbody></table>
<h4 id="六、EXT（Bit-Extender）"><a href="#六、EXT（Bit-Extender）" class="headerlink" title="六、EXT（Bit Extender）"></a>六、EXT（Bit Extender）</h4><ul>
<li>将16位偏移量&#x2F;立即数拓展至32位</li>
</ul>
<table>
<thead>
<tr>
<th>端口名</th>
<th>输入&#x2F;输出</th>
<th>位宽</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>EXT Select</td>
<td>in</td>
<td>1</td>
<td>选择符号拓展&#x2F;无符号拓展（0&#x2F;1）</td>
</tr>
<tr>
<td>in</td>
<td>in</td>
<td>16</td>
<td>16位输入</td>
</tr>
<tr>
<td>out</td>
<td>out</td>
<td>32</td>
<td>拓展后32位输出</td>
</tr>
</tbody></table>
<h4 id="七、CU（Control-Unit）"><a href="#七、CU（Control-Unit）" class="headerlink" title="七、CU（Control Unit）"></a>七、CU（Control Unit）</h4><ul>
<li>生成所有控制信号的组合逻辑电路</li>
<li>根据每条指令的数据通路列出如下控制信号表格</li>
<li>R指令控制信号为 (R&#x3D;&#x3D;0)</li>
<li>分别根据Opcode和Funct每一位和与门控制非R和R型指令的选择</li>
<li>再将控制信号用或门收集所有需要触发的指令（多连接一个常数0防止没有被选择的时候输出X）</li>
</ul>
<table>
<thead>
<tr>
<th>Instuction</th>
<th>Opcode(in)</th>
<th>Funct (in)</th>
<th>RegWrite</th>
<th>RegDst</th>
<th>ALUsrc</th>
<th>Branch</th>
<th>MemWrite</th>
<th>MemToReg</th>
<th>EXTselect</th>
<th>Jump</th>
<th>ALUControl</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td>000000</td>
<td>100000</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>000</td>
</tr>
<tr>
<td>sub</td>
<td>000000</td>
<td>100010</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>001</td>
</tr>
<tr>
<td>ori</td>
<td>001101</td>
<td></td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>010</td>
</tr>
<tr>
<td>lw</td>
<td>100011</td>
<td></td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>000</td>
</tr>
<tr>
<td>sw</td>
<td>101011</td>
<td></td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>000</td>
</tr>
<tr>
<td>beq</td>
<td>000100</td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>000</td>
</tr>
<tr>
<td>lui</td>
<td>001111</td>
<td></td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>011</td>
</tr>
<tr>
<td>j</td>
<td>000010</td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>00</td>
</tr>
</tbody></table>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="汇编代码"><a href="#汇编代码" class="headerlink" title="汇编代码"></a>汇编代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ori $a0,$0,1999        #ori 测试程序要实现: $0寄存器中的内容与立即数 0x000007cf进行或运算，储存在$a0寄存器中</span><br><span class="line">ori $a1,$a0,111         #ori 测试程序要实现: $a0寄存器中的内容与立即数 0x0000006f进行或运算，储存在$a1寄存器中</span><br><span class="line">lui $a2,12345            #lui 测试程序要实现: 立即数 0x00003039 加载至 $a2 寄存器的高位</span><br><span class="line">lui $a3,0xffff          #lui 测试程序要实现: 立即数 0x0000ffff 加载至 $a3 寄存器的高位</span><br><span class="line">ori $a3,$a3,0xffff     #ori 测试程序要实现: $a3寄存器中的内容与立即数 0x0000ffff进行或运算，储存在$a3寄存器中</span><br><span class="line">add $s0,$a0,$a1        #addu 测试程序要实现：a0 寄存器中的值加上a1 后存到 s0 寄存器中</span><br><span class="line">add $s1,$a3,$a3         #addu 测试程序要实现：a3 寄存器中的值加上a3 后存到 s1 寄存器中</span><br><span class="line">add $s2,$a3,$s0         #addu 测试程序要实现：a3 寄存器中的值加上s0 后存到 s2 寄存器中</span><br><span class="line">sub $s0,$a0,$s2        #subu 测试程序要实现：a0 寄存器中的值减去 s2 寄存器中的值后存到 s0 寄存器中</span><br><span class="line">sub $s1,$a3,$a3        #subu 测试程序要实现：a3 寄存器中的值减去 a3 寄存器中的值后存到 s1 寄存器中</span><br><span class="line">eee:</span><br><span class="line">sub $s2,$a3,$a0         #subu 测试程序要实现：a3 寄存器中的值减去 a0 寄存器中的值后存到 s2 寄存器中</span><br><span class="line">sub $s3,$s2,$s1         #subu 测试程序要实现：s2 寄存器中的值减去 s1 寄存器中的值后存到 s3 寄存器中</span><br><span class="line">ori $t0,$0,0x0000       #ori 测试程序要实现: $0寄存器中的内容与立即数 0x00000000进行或运算，储存在$t0寄存器中</span><br><span class="line">sw $a0,0($t0)           #sw 测试程序要实现：把 a0 寄存器中值,存储到t0寄存器的值再加上偏移量 0， 所指向的 RAM 中</span><br><span class="line">nop</span><br><span class="line">sw $a1,4($t0)       #sw 测试程序要实现：把 a1 寄存器中值,存储到t0寄存器的值再加上偏移量 4， 所指向的 RAM 中</span><br><span class="line">sw $s0,8($t0)       #sw 测试程序要实现：把 s0 寄存器中值,存储到t0寄存器的值再加上偏移量 8， 所指向的 RAM 中</span><br><span class="line">sw $s1,12($t0)      #sw 测试程序要实现：把 s1 寄存器中值,存储到t0寄存器的值再加上偏移量 12， 所指向的 RAM 中</span><br><span class="line">sw $s2,16($t0)      #sw 测试程序要实现：把 s2 寄存器中值,存储到t0寄存器的值再加上偏移量 16， 所指向的 RAM 中</span><br><span class="line">lw $t7,0($t0)        #lw 测试程序要实现：把 t0 寄存器的值加上偏移量0 当作地址读取存储器中的值存入 t7</span><br><span class="line">lw $t6,20($t0)      #lw 测试程序要实现：把 t0 寄存器的值加上偏移量20 当作地址读取存储器中的值存入 t6</span><br><span class="line">ori $t0,$t0,1       #ori 测试程序要实现: $t0寄存器中的内容与立即数 0x00000001进行或运算，储存在$t0寄存器中</span><br><span class="line">ori $t1,$t1,1       #ori 测试程序要实现: $t1寄存器中的内容与立即数 0x00000001进行或运算，储存在$t1寄存器中</span><br><span class="line">ori $t2,$t2,2       #ori 测试程序要实现: $t2寄存器中的内容与立即数 0x00000002进行或运算，储存在$t2寄存器中</span><br><span class="line">beq $t0,$t2,eee     #beq 测试程序要实现：判断 t0 的值和 t2 的值是否相等，相等转eee</span><br><span class="line">beq $t0,$t1,end     #beq 测试程序要实现：判断 t0 的值和 t1 的值是否相等，相等转end</span><br><span class="line">lui $t3,1111     #lui 测试程序要实现: 立即数 0x00000457 加载至 $t3 寄存器的高位</span><br><span class="line">end:</span><br><span class="line">add $t0,$t0,$t7   #addu 测试程序要实现：t0 寄存器中的值加上t0 后存到 t0 寄存器中</span><br><span class="line">j end2</span><br><span class="line">#j 测试</span><br><span class="line">sw $t7,48($t0)       #sw 测试程序要实现：把 t6 寄存器中值,存储到t0寄存器的值再加上偏移量 24， 所指向的 RAM 中</span><br><span class="line">lw $t5,48($t0)     #lw 测试程序要实现：把 t0 寄存器的值加上偏移量12 当作地址读取存储器中的值存入 t5</span><br><span class="line">end2:</span><br></pre></td></tr></table></figure>

<h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v2.0 raw</span><br><span class="line">340407cf</span><br><span class="line">3485006f</span><br><span class="line">3c063039</span><br><span class="line">3c07ffff</span><br><span class="line">34e7ffff</span><br><span class="line">00858020</span><br><span class="line">00e78820</span><br><span class="line">00f09020</span><br><span class="line">00928022</span><br><span class="line">00e78822</span><br><span class="line">00e49022</span><br><span class="line">02519822</span><br><span class="line">34080000</span><br><span class="line">ad040000</span><br><span class="line">00000000</span><br><span class="line">ad050004</span><br><span class="line">ad100008</span><br><span class="line">ad11000c</span><br><span class="line">ad120010</span><br><span class="line">8d0f0000</span><br><span class="line">8d0e0014</span><br><span class="line">35080001</span><br><span class="line">35290001</span><br><span class="line">354a0002</span><br><span class="line">110afff1</span><br><span class="line">11090001</span><br><span class="line">3c0b0457</span><br><span class="line">010f4020</span><br><span class="line">08000c1f</span><br><span class="line">ad0f0030</span><br><span class="line">8d0d0030</span><br></pre></td></tr></table></figure>

<h4 id="mips运行结果"><a href="#mips运行结果" class="headerlink" title="mips运行结果"></a>mips运行结果</h4><img src="image-20230310234528268.png" alt="image-20230310234528268"/>

<img src="image-20221030204922910.png" alt="image-20221030204922910"/>

<h4 id="CPU运行结果"><a href="#CPU运行结果" class="headerlink" title="CPU运行结果"></a>CPU运行结果</h4><img src="image-20221030204850105.png" alt="image-20221030204850105"/>

<img src="image-20221030204822588.png" alt="image-20221030204822588"/>

<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li><strong>上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。</strong><ol>
<li>状态储存：PC, GRF, IM, DM（储存指令以及数据的状态）</li>
<li>状态转移：ALU, EXT, CU（组合逻辑）</li>
</ol>
</li>
<li><strong>现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。</strong><ol>
<li>合理，IM用ROM存储指令，掉电后不会丢失，并且需要人为进行修改，保证指令不会在运行中被更改；数据储存用RAM，读出和写入且访问速度快于ROM，方便每个周期读出或者写入；同时内存可能很大，不可用Register实现；GRF一共32个数据，每个周期内需要频繁同时读出和写入，用Register效率最高</li>
</ol>
</li>
<li><strong>在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。</strong><ol>
<li>暂无</li>
</ol>
</li>
<li><strong>事实上，实现 <code>nop</code> 空指令，我们并不需要将它加入控制信号真值表，为什么？</strong><ol>
<li>CU中无指令被选择时，所有控制信号输出0，不对GRF写入，不对DM写入，rs与rt均全为0，在GRF选择的均为0号寄存器，输出为0，ALU运算后仍为0，即操作为将0写回$0寄存器，所以不需要加入控制信号真值表</li>
</ol>
</li>
<li><strong>上文提到，MARS 不能导出 PC 与 DM 起始地址均为 0 的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。</strong><ol>
<li>将地址减去0x30000000，映射到0x00000000为起始地址</li>
</ol>
</li>
<li><strong>阅读 Pre 的 <a href="http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/">“MIPS 指令集及汇编语言”</a> 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。</strong><ol>
<li>beq指令强度不足，只包括向后跳转，没有测试向前跳转的负立即数</li>
<li>ori指令还可测试对$0寄存器赋值，检测是否会修改</li>
<li>对DM和GRF，存取数据地址最好包含整个要求的地址范围和32个寄存器，保证范围设置正确，连接正确</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Computer Orgnization</category>
      </categories>
      <tags>
        <tag>Computer Orgnization</tag>
      </tags>
  </entry>
  <entry>
    <title>P4设计文档</title>
    <url>/2023/03/10/19-16-42/</url>
    <content><![CDATA[<h2 id="CPU设计文档"><a href="#CPU设计文档" class="headerlink" title="CPU设计文档"></a>CPU设计文档</h2><span id="more"></span>
<h3 id="支持指令"><a href="#支持指令" class="headerlink" title="支持指令"></a>支持指令</h3><p>add, sub, ori, lui, lw, sw, beq,bne, j, jr, jal, sll, nop</p>
<p>(其中add，sub为无符号加减法)</p>
<table>
<thead>
<tr>
<th>Instuction</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><em>add</em></td>
<td>GPR[rd] &#x3D; GPR[rs] + GPR[rt]</td>
</tr>
<tr>
<td><em>sub</em></td>
<td>GPR[rd] &#x3D; GPR[rs] - GPR[rt]</td>
</tr>
<tr>
<td><em>ori</em></td>
<td>GPR[rt] &#x3D;  GPR[rs] | ZeroExt(Imm)</td>
</tr>
<tr>
<td><em>lui</em></td>
<td>GPR[rt] &#x3D;  {imm, 16’b0}</td>
</tr>
<tr>
<td><em>lw</em></td>
<td>R[rt] &#x3D;  Mem[GPR[rs]+sign_ext(offset)]</td>
</tr>
<tr>
<td><em>sw</em></td>
<td>Mem[GPR[rs]+sign_ext(offset)] &#x3D; R[rt]</td>
</tr>
<tr>
<td><em>beq</em></td>
<td>if (GPR[rs] &#x3D;&#x3D;  GPR[rt])  PC &#x3D; PC + 4 + BranchAddr</td>
</tr>
<tr>
<td><em>j</em></td>
<td>PC &#x3D; JumpAddr</td>
</tr>
<tr>
<td><em>jal</em></td>
<td>PC &#x3D;  JumpAddr; GPR[31] &#x3D; PC + 4</td>
</tr>
<tr>
<td><em>jr</em></td>
<td>PC &#x3D; GPR[rs]</td>
</tr>
<tr>
<td><em>sll</em></td>
<td>GPR[rd] &#x3D; {GPR[rt] [31-s:0] , s{0}}</td>
</tr>
<tr>
<td>bne</td>
<td>if (GPR[rs] !&#x3D; GPR[rt]) PC &#x3D; PC + 4 + BranchAddr</td>
</tr>
</tbody></table>
<h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><img src="image-20230311000307141.png" alt="image-20230311000307141"/>

<h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><h4 id="一、IFU（Instruction-Fetch-Unit）"><a href="#一、IFU（Instruction-Fetch-Unit）" class="headerlink" title="一、IFU（Instruction Fetch Unit）"></a>一、IFU（Instruction Fetch Unit）</h4><ul>
<li>包括PC和IM</li>
<li>容量为16KiB（4096 × 32bit）:  reg [31:0] IM [0:4095]</li>
<li>注意起始地址为0x00003000，address应为PC-0x00003000，后再取[13:2]位，在IM堆中对应地址</li>
</ul>
<table>
<thead>
<tr>
<th>端口名</th>
<th>输入&#x2F;输出</th>
<th>位宽</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>in</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>in</td>
<td>1</td>
<td>同步复位</td>
</tr>
<tr>
<td>PCSrc</td>
<td>in</td>
<td>1</td>
<td>下一指令地址选择信号</td>
</tr>
<tr>
<td>Jump</td>
<td>in</td>
<td>1</td>
<td>跳转控制信号</td>
</tr>
<tr>
<td>shiftResult</td>
<td>in</td>
<td>[31:0]</td>
<td>偏移后的指令地址</td>
</tr>
<tr>
<td>jumpAdd</td>
<td>in</td>
<td>[31:0]</td>
<td>直接跳转的指令地址</td>
</tr>
<tr>
<td>PC</td>
<td>out</td>
<td>[31:0]</td>
<td>输出当前地址</td>
</tr>
<tr>
<td>D</td>
<td>out</td>
<td>[31:0]</td>
<td>输出读取指令</td>
</tr>
</tbody></table>
<h4 id="二、GRF（General-Register-File）"><a href="#二、GRF（General-Register-File）" class="headerlink" title="二、GRF（General Register File）"></a>二、GRF（General Register File）</h4><ul>
<li>存储$0~$31这32个寄存器数据：reg [31:0] GRF [31:0]</li>
<li>具有<strong>同步复位</strong>，读、写功能</li>
<li>$0寄存器输入为常数0（如果WA&#x3D;&#x3D;0，不写）</li>
</ul>
<table>
<thead>
<tr>
<th>端口名</th>
<th>输入&#x2F;输出</th>
<th>位宽</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>in</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>in</td>
<td>1</td>
<td>同步复位</td>
</tr>
<tr>
<td>WE(RegWrite)</td>
<td>in</td>
<td>1</td>
<td>写入使能信号</td>
</tr>
<tr>
<td>A1(GRF_A1)</td>
<td>in</td>
<td>[4:0]</td>
<td>输出数据到RD1的寄存器的地址</td>
</tr>
<tr>
<td>A2(GRF_A2)</td>
<td>in</td>
<td>[4:0]</td>
<td>输出数据到RD2的寄存器的地址</td>
</tr>
<tr>
<td>WA(GRF_WA)</td>
<td>in</td>
<td>[4:0]</td>
<td>输入到寄存器的地址</td>
</tr>
<tr>
<td>WD((GRF_WD)</td>
<td>in</td>
<td>[31:0]</td>
<td>写入的数据</td>
</tr>
<tr>
<td>RD1(GRF_RD1)</td>
<td>out</td>
<td>[31:0]</td>
<td>RD1输出的数据</td>
</tr>
<tr>
<td>RD2(GRF_RD2)</td>
<td>out</td>
<td>[31:0]</td>
<td>RD2输出的数据</td>
</tr>
</tbody></table>
<h4 id="三、ALU（Arithmetic-amp-logical-Unit）"><a href="#三、ALU（Arithmetic-amp-logical-Unit）" class="headerlink" title="三、ALU（Arithmetic &amp; logical Unit）"></a>三、ALU（Arithmetic &amp; logical Unit）</h4><ul>
<li><p>提供 32 位加、减、或运算、高16位赋0以及大小比较功能</p>
</li>
<li><p>加减法按无符号处理</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>端口名</th>
<th>输入&#x2F;输出</th>
<th>位宽</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>op</td>
<td>in</td>
<td>[2:0]</td>
<td>ALU功能控制信号 <strong>000</strong>：加；<strong>001</strong>；减；<strong>010</strong>：或；<strong>011</strong>：高16位赋0</td>
</tr>
<tr>
<td>A(ALU_A)</td>
<td>in</td>
<td>[31:0]</td>
<td>输入1</td>
</tr>
<tr>
<td>B(ALU_B)</td>
<td>in</td>
<td>[31:0]</td>
<td>输入2</td>
</tr>
<tr>
<td>Y((ALU_Y)</td>
<td>out</td>
<td>[31:0]</td>
<td>输出</td>
</tr>
<tr>
<td>Greater</td>
<td>out</td>
<td>1</td>
<td>A&gt;B</td>
</tr>
<tr>
<td>Equal</td>
<td>out</td>
<td>1</td>
<td>A&#x3D;B</td>
</tr>
<tr>
<td>Less</td>
<td>out</td>
<td>1</td>
<td>A&lt;B</td>
</tr>
</tbody></table>
<h4 id="四、DM（Data-Memory）"><a href="#四、DM（Data-Memory）" class="headerlink" title="四、DM（Data Memory）"></a>四、DM（Data Memory）</h4><ul>
<li>容量为16KiB（4096 × 32bit）:  reg [31:0] DM [0:4095]</li>
<li>具有<strong>同步复位</strong>，读、写功能，复位地址为 0x00000000</li>
</ul>
<table>
<thead>
<tr>
<th>端口名</th>
<th>输入&#x2F;输出</th>
<th>位宽</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>in</td>
<td>1</td>
<td>时钟信号</td>
</tr>
<tr>
<td>reset</td>
<td>in</td>
<td>1</td>
<td>同步复位</td>
</tr>
<tr>
<td>WE(MemWrite)</td>
<td>in</td>
<td>1</td>
<td>写控制信号</td>
</tr>
<tr>
<td>A(DM_A)</td>
<td>in</td>
<td>[4:0]</td>
<td>要读&#x2F;写的存储器的地址</td>
</tr>
<tr>
<td>WD(DM_WD)</td>
<td>in</td>
<td>[31:0]</td>
<td>写入的数据</td>
</tr>
<tr>
<td>RD(DM_RD)</td>
<td>out</td>
<td>[31:0]</td>
<td>读出的数据</td>
</tr>
</tbody></table>
<h4 id="五、EXT（Bit-Extender）"><a href="#五、EXT（Bit-Extender）" class="headerlink" title="五、EXT（Bit Extender）"></a>五、EXT（Bit Extender）</h4><ul>
<li>将16位偏移量&#x2F;立即数拓展至32位</li>
</ul>
<table>
<thead>
<tr>
<th>端口名</th>
<th>输入&#x2F;输出</th>
<th>位宽</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>EXTSelect</td>
<td>in</td>
<td>1</td>
<td>选择符号拓展&#x2F;无符号拓展（0&#x2F;1）</td>
</tr>
<tr>
<td>in(EXT_in)</td>
<td>in</td>
<td>[15:0]</td>
<td>16位输入</td>
</tr>
<tr>
<td>out(EXT_out)</td>
<td>out</td>
<td>[31:0]</td>
<td>拓展后32位输出</td>
</tr>
</tbody></table>
<h4 id="六、CU（Control-Unit）"><a href="#六、CU（Control-Unit）" class="headerlink" title="六、CU（Control Unit）"></a>六、CU（Control Unit）</h4><ul>
<li>生成所有控制信号的组合逻辑</li>
<li>根据每条指令的数据通路列出如下控制信号表格</li>
<li>R指令控制信号为（R&#x3D;&#x3D;0)</li>
<li>分别根据Opcode和Funct每一位和与门控制非R和R型指令的选择</li>
<li>再将指令信号通过或连接，表示某一控制信号被哪些指令选择</li>
</ul>
<table>
<thead>
<tr>
<th>Instuction</th>
<th>Opcode（in)</th>
<th>Funct (in)</th>
<th>RegWrite</th>
<th>GRF_WASrc</th>
<th>GRF_WDSrc</th>
<th>ALUSrc</th>
<th>ALUSelect</th>
<th>MemWrite</th>
<th>EXTSelect</th>
<th>Branch</th>
<th>BranchSelect</th>
<th>Jump</th>
<th>Jr</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td>000000</td>
<td>100000</td>
<td>1</td>
<td>001</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>sub</td>
<td>000000</td>
<td>100010</td>
<td>1</td>
<td>001</td>
<td></td>
<td></td>
<td>001</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ori</td>
<td>001101</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td>010</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>lui</td>
<td>001111</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td>011</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>sw</td>
<td>101011</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>lw</td>
<td>100011</td>
<td></td>
<td>1</td>
<td></td>
<td>001</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>beq</td>
<td>000100</td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td>000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>j</td>
<td>000010</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>jal</td>
<td>000011</td>
<td></td>
<td>1</td>
<td>010</td>
<td>010</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>jr</td>
<td>000000</td>
<td>001000</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>000</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>sll</td>
<td>000000</td>
<td>000000</td>
<td>1</td>
<td>001</td>
<td>011</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>bne</td>
<td>000101</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td>001</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="logisim图示"><a href="#logisim图示" class="headerlink" title="logisim图示"></a>logisim图示</h3><img src="image-20221107194455075.png" alt="image-20221107194455075"/>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>注：自造指令的同时借助zby同学的自动化测试工具大范围覆盖，以下仅放出自造指令，以及自动化测试结果截图。</p>
<h3 id="asm指令"><a href="#asm指令" class="headerlink" title="asm指令"></a>asm指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ori $1,11</span><br><span class="line">ori $2,22</span><br><span class="line">ori $3,33</span><br><span class="line">lui $4,12</span><br><span class="line">lui $5,23</span><br><span class="line">lui $6,24</span><br><span class="line">lui $7,25</span><br><span class="line">lui $8,34</span><br><span class="line">lui $9,12</span><br><span class="line">addu $10,$9,$9</span><br><span class="line">addu $11,$2,$3</span><br><span class="line">addu $12,$5,$6</span><br><span class="line">subu $13,$3,$5</span><br><span class="line">subu $14,$5,$4</span><br><span class="line">subu $15,$2,$6</span><br><span class="line">nop</span><br><span class="line">lui $16,12</span><br><span class="line">beq $9,$16, next</span><br><span class="line">nop</span><br><span class="line">lui $1,1</span><br><span class="line">lui $2,1</span><br><span class="line">lui $3,1</span><br><span class="line">lui $4,1</span><br><span class="line">a:</span><br><span class="line">lui $5,1</span><br><span class="line">lui $6,1</span><br><span class="line">lui $7,1</span><br><span class="line">lui $8,1</span><br><span class="line">lui $9,1</span><br><span class="line">lui $10,1</span><br><span class="line">next:</span><br><span class="line">beq $1,$2, a</span><br><span class="line">sw $1,0($0)</span><br><span class="line">sw $2,4($0)</span><br><span class="line">sw $3,8($0)</span><br><span class="line">sw $4,12($0)</span><br><span class="line">sw $5,16($0)</span><br><span class="line">sw $6,20($0)</span><br><span class="line">sw $7,24($0)</span><br><span class="line">lw $17,0($0)</span><br><span class="line">lw $18,4($0)</span><br><span class="line">jal out </span><br><span class="line">lw $19, 8($0)</span><br><span class="line">jal end</span><br><span class="line">out:</span><br><span class="line">lw $0,0($0)</span><br><span class="line">jr $31</span><br><span class="line">end:</span><br><span class="line">subu $3,$3,$0</span><br><span class="line">subu $31,$0, $31</span><br></pre></td></tr></table></figure>

<h4 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">34040100</span><br><span class="line">34850123</span><br><span class="line">3c0601c8</span><br><span class="line">3c07ffff</span><br><span class="line">34e7ffff</span><br><span class="line">00868021</span><br><span class="line">00878821</span><br><span class="line">00e7a021</span><br><span class="line">00869023</span><br><span class="line">00879823</span><br><span class="line">ac040000</span><br><span class="line">ac050004</span><br><span class="line">ac060008</span><br><span class="line">ac07000c</span><br><span class="line">ac100010</span><br><span class="line">ac110014</span><br><span class="line">ac120018</span><br><span class="line">ac13002c</span><br><span class="line">ac140030</span><br><span class="line">8c040000</span><br><span class="line">8c05000c</span><br><span class="line">ac04001c</span><br><span class="line">ac050020</span><br><span class="line">34040001</span><br><span class="line">34050002</span><br><span class="line">34060001</span><br><span class="line">10850001</span><br><span class="line">10860001</span><br><span class="line">ad040024</span><br><span class="line">ad050028</span><br><span class="line">0c000c23</span><br><span class="line">0c000c23</span><br><span class="line">ad150040</span><br><span class="line">34a50004</span><br><span class="line">0c000c27</span><br><span class="line">ad050038</span><br><span class="line">ad1f003c</span><br><span class="line">36b50005</span><br><span class="line">03e00008</span><br><span class="line">ad050044</span><br><span class="line">ad1f0048</span><br></pre></td></tr></table></figure>

<h4 id="输出（文本比较）"><a href="#输出（文本比较）" class="headerlink" title="输出（文本比较）"></a>输出（文本比较）</h4><img src="image-20221104233120667.png" alt="image-20221104233120667"/>

<p>左侧为zby测评机自mars导出的输出，右侧为verilog中的输出（0号寄存器写入输出可有可无）</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li><ul>
<li>DM地址来为GPR[rs]+sign_ext(offset)，来自EXT对寄存器中地址rs寄存器的值符号拓展的输出</li>
<li>为[11:2]以对应从DM地址32位中截取的[11:2]位，截去低2位，从字节为单位的PC对应到以32bit为单位的DM</li>
</ul>
</li>
<li><pre><code class="assembly"> //指令对应的控制信号如何取值
     always @(*) begin
         if(add) begin
             assign RegWrite=1;
             assign RegDst=1;
         end
         else if(sub) begin
             assign RegWrite=1;
             assign RegDst=1;
             assign ALUControl=3&#39;b001;
         end
     end
 //控制信号每种取值所对应的指令
  assign RegWrite=(add||sub||ori||lw||lui||jal);
     assign RegDst=(add||sub);
     assign ALUSrc=(ori||lw||sw||lui);
     assign Branch=(beq);
     assign MemWrite=(sw);
     assign MemToReg=(lw);
     assign EXTSelect=(ori||lui);
     assign Jump=(j||jal||jr);
     assign ALUControl=sub?3&#39;b001:
                       ori?3&#39;b010:
                       lui?3&#39;b011:
                       3&#39;b000;
     assign Jal=(jal);
     assign Jr=(jr);
</code></pre>
<p> 第一种方法优点在于添加新指令，修改更加集中，不会遗漏控制信号；缺点为当指令种类过多时，篇幅过长。</p>
<p> 第二种方法优点为控制条件更加集中，可读性更强，如ALU信号含义更明确，不会错误对应；缺点为增加新指令时需修改多处。</p>
</li>
<li><p>信号优先级：</p>
<ul>
<li><p>同步复位：clk&gt;reset</p>
</li>
<li><p>异步复位：reset&gt;clk</p>
</li>
</ul>
</li>
<li><p>add,addi具有溢出检测，如果溢出，则不讲加法运算结果写入寄存器。但此结果截断低32位后与addu,addiu的运算结果相同。此时如果忽略溢出信号，照常写入，则写入值相同，即add与addu，addi与addiu等价</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Computer Orgnization</category>
      </categories>
      <tags>
        <tag>Computer Orgnization</tag>
      </tags>
  </entry>
  <entry>
    <title>P6设计文档</title>
    <url>/2023/03/10/19-16-51/</url>
    <content><![CDATA[<h2 id="5级流水线CPU设计文档"><a href="#5级流水线CPU设计文档" class="headerlink" title="5级流水线CPU设计文档+"></a>5级流水线CPU设计文档+</h2><span id="more"></span>

<h2 id="支持指令"><a href="#支持指令" class="headerlink" title="支持指令"></a>支持指令</h2><p>  <strong>R, add, sub, And, Or, Xor, slt, sltu</strong></p>
<p>  <strong>addi, andi, xori, ori, lui</strong></p>
<p>  <strong>lb, lh, lw, sb, sh, sw, lbu, lhu</strong></p>
<p>  <strong>mult, multu, div, divu, mfhi, mflo, mthi, mtlo</strong></p>
<p>  <strong>beq, bne, j, jal, jr, bltzal</strong></p>
<p>  <strong>sll</strong></p>
<h2 id="流程模块设计"><a href="#流程模块设计" class="headerlink" title="流程模块设计"></a>流程模块设计</h2><h3 id="CU模块设计"><a href="#CU模块设计" class="headerlink" title="CU模块设计"></a>CU模块设计</h3><ul>
<li>相较P4，省去RegWrite信号，直接译出当前指令需要写入的地址，如不需写入，默认写至0，在写入GRF时直接略去</li>
<li>直接译出当前指令rs, rt, rd, shamt, imm16, imm26以及所有控制信号供每个阶段选取使用，还需译出Tuse_rs&#x2F;rt以及E_Tnew与M_Tnew，各级输出对应信号至Conflict模块</li>
<li>将指令分类，分为：cal_r,cal_i,md,mt,mf,load,save,branch,branch_ucl,branch_cl,shift,jreg,jadd,jlink（ori被归为cal_i）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   assign cal_r=(add||sub||And||Or||Xor||slt||sltu);</span><br><span class="line">assign cal_i=(addi||andi||xori||ori||lui);</span><br><span class="line"></span><br><span class="line">   assign md   =(mult||multu||div||divu);</span><br><span class="line">   assign mf   =(mfhi||mflo);</span><br><span class="line">   assign mt   =(mthi||mtlo);</span><br><span class="line"></span><br><span class="line">assign load=(lw||lh||lhu||lb||lbu);</span><br><span class="line">assign save=(sw||sh||sb);</span><br><span class="line"></span><br><span class="line">   assign branch=(beq||bne||branch_ucl||branch_cl);</span><br><span class="line">   assign branch_ucl=bltzal;</span><br><span class="line">   assign branch_cl=0;</span><br><span class="line"></span><br><span class="line">   assign jreg = jr;</span><br><span class="line">   assign jadd = (j||jal);</span><br><span class="line">   assign jlink = jal;</span><br><span class="line"></span><br><span class="line">   assign shift=sll;</span><br></pre></td></tr></table></figure>

<ul>
<li>控制信号新增：MDU, MDUStart, MDUSelect, MFSelect, ByteSelect, DESelect</li>
<li>控制信号调整：GRF_WA, GRF_WDSrc, ALUSelect, <strong>EXTSelect（cal_i各个指令行为不同，注意对照指令集）</strong>,BranchSelect</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Ins</td>
<td>input</td>
<td>[31:0]</td>
<td>当级指令</td>
</tr>
<tr>
<td>branchTrue</td>
<td>input</td>
<td></td>
<td>分支控制信号</td>
</tr>
<tr>
<td><strong>控制信号</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GRF_WA</td>
<td>output</td>
<td>[4:0]</td>
<td>写入的地址</td>
</tr>
<tr>
<td>GRF_WDSrc</td>
<td>output</td>
<td>[2:0]</td>
<td>写入数据选择</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>EXTSelect</td>
<td>output</td>
<td></td>
<td>EXT位拓展类型选择</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ALUSrc</td>
<td>output</td>
<td></td>
<td>ALU_B的数据源选择</td>
</tr>
<tr>
<td>ALUSelect</td>
<td>output</td>
<td>[3:0]</td>
<td>ALU运算类型选择</td>
</tr>
<tr>
<td><u>MDU</u></td>
<td>output</td>
<td></td>
<td>乘除运算+读写HI LO信号（需要阻塞）</td>
</tr>
<tr>
<td><u>MDUStart</u></td>
<td>output</td>
<td></td>
<td>乘除运算开始信号</td>
</tr>
<tr>
<td><u>MDUSelect</u></td>
<td>output</td>
<td>[2:0]</td>
<td>乘除运算+写HI LO功能选择</td>
</tr>
<tr>
<td><u>MFSelect</u></td>
<td>output</td>
<td>[1:0]</td>
<td>读HI LO功能选择</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>MemWrite</td>
<td>output</td>
<td></td>
<td>内存写入控制</td>
</tr>
<tr>
<td>BranchSelect</td>
<td>output</td>
<td>[3:0]</td>
<td>branch判断类型选择</td>
</tr>
<tr>
<td>NPCSelect</td>
<td>output</td>
<td>[2:0]</td>
<td>NPC类型选择</td>
</tr>
<tr>
<td><u>ByteSelect</u></td>
<td>output</td>
<td>[1:0]</td>
<td>访存数据类型选择</td>
</tr>
<tr>
<td><u>DESelect</u></td>
<td>output</td>
<td>[2:0]</td>
<td>读取内存后结果拓展类型</td>
</tr>
<tr>
<td><strong>指令译码</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>opcode</td>
<td>output</td>
<td>[5:0]</td>
<td></td>
</tr>
<tr>
<td>funct</td>
<td>output</td>
<td>[5:0]</td>
<td></td>
</tr>
<tr>
<td>rs</td>
<td>output</td>
<td>[4:0]</td>
<td></td>
</tr>
<tr>
<td>rt</td>
<td>output</td>
<td>[4:0]</td>
<td></td>
</tr>
<tr>
<td>rd</td>
<td>output</td>
<td>[4:0]</td>
<td></td>
</tr>
<tr>
<td>shamt</td>
<td>output</td>
<td>[4:0]</td>
<td></td>
</tr>
<tr>
<td>imm16</td>
<td>output</td>
<td>[15:0]</td>
<td></td>
</tr>
<tr>
<td>imm26</td>
<td>output</td>
<td>[25:0]</td>
<td></td>
</tr>
<tr>
<td><strong>T计算</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Tuse_rs</td>
<td>output</td>
<td>[1:0]</td>
<td></td>
</tr>
<tr>
<td>Tuse_rt</td>
<td>output</td>
<td>[1:0]</td>
<td></td>
</tr>
<tr>
<td>E_Tnew</td>
<td>output</td>
<td>[1:0]</td>
<td></td>
</tr>
<tr>
<td>M_Tnew</td>
<td>output</td>
<td>[1:0]</td>
<td></td>
</tr>
</tbody></table>
<h4 id="T计算表格"><a href="#T计算表格" class="headerlink" title="T计算表格"></a>T计算表格</h4><ul>
<li>注意新增的乘除指令的AT</li>
</ul>
<table>
<thead>
<tr>
<th>Ins</th>
<th>Tuse_rs</th>
<th>Tuse_rt</th>
<th>E_Tnew</th>
<th>M_Tnew</th>
</tr>
</thead>
<tbody><tr>
<td>cal_r</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>cal_i</td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
</tr>
<tr>
<td><u>md</u></td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td><u>mt</u></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><u>mf</u></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>load</td>
<td>2</td>
<td></td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>save</td>
<td>1</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>branch</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>jreg</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Conflit模块设计：AT控制阻塞，直接转发"><a href="#Conflit模块设计：AT控制阻塞，直接转发" class="headerlink" title="Conflit模块设计：AT控制阻塞，直接转发"></a>Conflit模块设计：AT控制阻塞，直接转发</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul>
<li>D级判断将要使用的寄存器数据是否能得到转发更新，即后续写入相同寄存器的Tnew是否有大于Tuse的，如果有则需要阻塞，以在后续能得到转发更新。特判0号寄存器不需要阻塞，能够直接获得数据0</li>
<li>需要得到D级指令rs, rt的Tuse，以及后续E, M级指令的Tnew，在各级CU中计算，发送至冲突单元（W级Tnew全是0不需要考虑，都可以内部转发解决）</li>
<li>阻塞时需要暂停更新PC以及F级读出的指令，并且清空D级当前指令的译码输出，以替换为nop空泡</li>
<li>新增乘除Stall，在乘除运算即将开始或正在进行时如遇到乘除指令需要Stall</li>
</ul>
<img src="image-20230311001016596.png" alt="image-20230311001016596"/>

<h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><ul>
<li><p>阻塞后，所有指令在需要读寄存器数据的时候都能够获得后续计算完毕的数据，每级转发出已算出的数据，发送给之前各级即可。</p>
</li>
<li><p>需要读寄存器：D级GRF，Branch计算需要rs, rt数据；E级ALU需要rs,rt 数据；M级DM写入数据口需要rt数据</p>
</li>
<li><p>需要写寄存器：E级可转发出D级算的PC+8；M级可转发出D级算的PC+8和E级算的的ALU_Y；W级可转发出D级算的PC+8，E级算的的ALU_Y和M级读出的DM数据。<strong>根据当前指令CU译码得到的GRF_WDSrc进行选择</strong>。此外还有W级寄存器写入，可直接内部转发至D级读出</p>
</li>
</ul>
<img src="image-20230311001109169.png" alt="image-20230311001109169" style="zoom:67%;" />

<img src="image-20230311001116883.png" alt="image-20230311001116883" style="zoom:67%;" />

<img src="image-20230311001122673.png" alt="image-20230311001122673" style="zoom:67%;" />

<img src="image-20230311001129478.png" alt="image-20230311001129478" style="zoom:67%;" />

<ul>
<li>在主模块中，获取各级需要读的寄存器编号（D_rs,D_rt,E_rs,E_rt,M_rt），寄存器原读数（D_rs_data,D_rt_data,E_rs_data,E_rt_data,M_rt_data），写入的寄存器编号（E_GRF_WA,M_GRF_WA,W_GRF_WA）和数据（E_GRF_WD,M_GRF_WD,W_GRF_WD）</li>
<li>比较读的编号和写的编号是否有相等的，如有相等的则代表有数据已经更新需要转发，转发优先级为更新次序，最后一次更新优先转发，即优先转发距离需要数据的阶段近的数据，特判如果需要读0号寄存器的数据，直接转发0</li>
<li>转发的数据（D_rs_fw,D_rt_fw,E_rs_fw,E_rt_fw,M_rt_fw）发送至各级需要的部分运算，并传递给下一级</li>
</ul>
<img src="image-20230311001150971.png" alt="image-20230311001150971" style="zoom: 67%;" />

<h3 id="五级模块设计"><a href="#五级模块设计" class="headerlink" title="五级模块设计"></a>五级模块设计</h3><ul>
<li><p>每个阶段之间以寄存器隔开，寄存器设计在每个模块输出处，使用reg类型</p>
</li>
<li><p>每个阶段之间需要流水传递Ins，PC，传给各级CU以译码出当前阶段的rs，rt以及需要写入的地址和写入数据的选择</p>
</li>
<li><p>部分阶段前后间需要传递需要使用的NPC, EXTout, ALU_Y, DM_RD</p>
</li>
</ul>
<h4 id="P6更新乘除槽与储存器外置以及按字节访存"><a href="#P6更新乘除槽与储存器外置以及按字节访存" class="headerlink" title="P6更新乘除槽与储存器外置以及按字节访存"></a>P6更新乘除槽与储存器外置以及按字节访存</h4><ul>
<li>删去F_IFU与M_DM，添加M_DE与E_MDU</li>
<li>乘除槽有两个寄存器，其中数据需要在EMW级流水，以便进行转发，并且需要添加转发信号控制</li>
<li>外置储存器需要修改数据通路，前寄存器发送写入数据，后寄存器接收读出数据</li>
</ul>
<h4 id="1-Fetch"><a href="#1-Fetch" class="headerlink" title="1. Fetch"></a>1. Fetch</h4><ul>
<li>包含FDReg</li>
<li>Fetch</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>F_Flush</td>
<td>input</td>
<td></td>
<td>清空延迟槽信号</td>
</tr>
<tr>
<td>F_Stall</td>
<td>input</td>
<td></td>
<td>阻塞更新PC</td>
</tr>
<tr>
<td>NPC</td>
<td>input</td>
<td>[31:0]</td>
<td>D级NPC计算出的NPC传入</td>
</tr>
<tr>
<td>F_PC</td>
<td><strong>output</strong></td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;NPC，传出至外部指令储存器</td>
</tr>
<tr>
<td>F_Ins</td>
<td><strong>input</strong></td>
<td>[31:0]</td>
<td>需要从外部指令储存器读入Ins</td>
</tr>
<tr>
<td><strong>FD寄存器</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>D_Stall</td>
<td>input</td>
<td></td>
<td>阻塞更新FD间寄存器</td>
</tr>
<tr>
<td>D_Flush</td>
<td>input</td>
<td></td>
<td>清除延迟槽信号</td>
</tr>
<tr>
<td>D_PC</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;F_PC</td>
</tr>
<tr>
<td>D_Ins</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;F_Ins</td>
</tr>
</tbody></table>
<ul>
<li>F级与指令储存的数据交换</li>
</ul>
<img src="image-20230311001208043.png" alt="image-20230311001208043" style="zoom:67%;" />

<h4 id="2-Decode"><a href="#2-Decode" class="headerlink" title="2. Decode"></a>2. Decode</h4><ul>
<li>包括D_CU, EXT, NPC (Branch), DEReg</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>D_PC</td>
<td>input</td>
<td>[31:0]</td>
<td>PC流水</td>
</tr>
<tr>
<td>D_Ins</td>
<td>input</td>
<td>[31:0]</td>
<td>指令流水</td>
</tr>
<tr>
<td><strong>Conflict&#x2F;Forward</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Tuse_rs</td>
<td>output</td>
<td>[1:0]</td>
<td>AT算阻塞</td>
</tr>
<tr>
<td>Tuse_rt</td>
<td>output</td>
<td>[1:0]</td>
<td></td>
</tr>
<tr>
<td>D_rs</td>
<td>output</td>
<td>[4:0]</td>
<td>D级指令读寄存器的编号</td>
</tr>
<tr>
<td>D_rt</td>
<td>output</td>
<td>[4:0]</td>
<td></td>
</tr>
<tr>
<td>D_rs_data</td>
<td>output</td>
<td>[31:0]</td>
<td>D级指令读寄存器原数据</td>
</tr>
<tr>
<td>D_rt_data</td>
<td>output</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>D_rs_fw</td>
<td>input</td>
<td>[31:0]</td>
<td>D级转发后寄存器数据</td>
</tr>
<tr>
<td>D_rt_fw</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td><strong>EXT</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>imm16</td>
<td></td>
<td>[15:0]</td>
<td>EXT输入</td>
</tr>
<tr>
<td>EXTSelect</td>
<td></td>
<td></td>
<td>EXT功能选择</td>
</tr>
<tr>
<td>D_EXT_out</td>
<td></td>
<td>[31:0]</td>
<td>EXT输出</td>
</tr>
<tr>
<td><strong>NPC</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>NPCSelect</td>
<td></td>
<td>[2:0]</td>
<td>下一指令地址选择</td>
</tr>
<tr>
<td>D_branchTrue</td>
<td></td>
<td></td>
<td>是否分支信号，进入流水</td>
</tr>
<tr>
<td>F_PC</td>
<td>input</td>
<td>[31:0]</td>
<td>算NPC用</td>
</tr>
<tr>
<td>NPC</td>
<td>output</td>
<td>[31:0]</td>
<td>传给F级IFU</td>
</tr>
<tr>
<td><strong>DEReg</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E_Flush</td>
<td>input</td>
<td></td>
<td>阻塞清空DE寄存器</td>
</tr>
<tr>
<td>E_PC</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;D_PC</td>
</tr>
<tr>
<td>E_Ins</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;D_Ins</td>
</tr>
<tr>
<td>E_rs_data</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;<strong>D_rs_fw</strong></td>
</tr>
<tr>
<td>E_rt_data</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;<strong>D_rt_fw</strong></td>
</tr>
<tr>
<td>E_EXT_out</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;D_EXT_out</td>
</tr>
<tr>
<td>E_branchTrue</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;D_branchTrue</td>
</tr>
</tbody></table>
<h4 id="3-Execute"><a href="#3-Execute" class="headerlink" title="3. Execute"></a>3. Execute</h4><ul>
<li>包括E_CU, E_ALU, E_MDU, EMReg</li>
<li>需在此处多向Conflict传递MDU指令以及乘除运行信息，并向流水中传递HI, LO以便mf指令W级读取</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>E_PC</td>
<td>input</td>
<td>[31:0]</td>
<td>PC流水</td>
</tr>
<tr>
<td>E_Ins</td>
<td>input</td>
<td>[31:0]</td>
<td>指令流水</td>
</tr>
<tr>
<td><strong>Conflict&#x2F;Forward</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E_branchTrue</td>
<td>input</td>
<td></td>
<td>是否分支信号</td>
</tr>
<tr>
<td>E_Tnew</td>
<td>output</td>
<td>[1:0]</td>
<td>AT算阻塞</td>
</tr>
<tr>
<td>E_rs</td>
<td>output</td>
<td>[4:0]</td>
<td>E级指令读寄存器的编号</td>
</tr>
<tr>
<td>E_rt</td>
<td>output</td>
<td>[4:0]</td>
<td></td>
</tr>
<tr>
<td>E_rs_data</td>
<td>output</td>
<td>[31:0]</td>
<td>E级指令读寄存器原数据</td>
</tr>
<tr>
<td>E_rt_data</td>
<td>output</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>E_GRF_WA</td>
<td>output</td>
<td>[4:0]</td>
<td>E级指令写寄存器的编号</td>
</tr>
<tr>
<td>E_rs_fw</td>
<td>input</td>
<td>[31:0]</td>
<td>E级接收转发后寄存器数据</td>
</tr>
<tr>
<td>E_rt_fw</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>GRF_WDSrc</td>
<td></td>
<td>[2:0]</td>
<td>E级指令写寄存器的数据选择</td>
</tr>
<tr>
<td>E_GRF_WD</td>
<td>output</td>
<td>[31:0]</td>
<td>E级指令写寄存器的数据</td>
</tr>
<tr>
<td><strong>ALU</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E_EXT_out</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>ALUSrc</td>
<td></td>
<td></td>
<td>ALU_B数据源选择</td>
</tr>
<tr>
<td>ALUSelect</td>
<td></td>
<td>[3:0]</td>
<td>ALU功能选择</td>
</tr>
<tr>
<td>E_ALU_A</td>
<td></td>
<td>[31:0]</td>
<td>&#x3D;<strong>E_rs_fw</strong>：ALU_A口数据</td>
</tr>
<tr>
<td>E_ALU_B</td>
<td></td>
<td>[31:0]</td>
<td>&#x3D;<strong>E_rt_fw</strong>&#x2F;E_EXT_out：ALU_B口数据</td>
</tr>
<tr>
<td><strong>MDU</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>MDU</td>
<td>output</td>
<td></td>
<td>MDU指令</td>
</tr>
<tr>
<td>MDUSelect</td>
<td></td>
<td>[2:0]</td>
<td>CU给MDU的功能选择</td>
</tr>
<tr>
<td>MDUStart</td>
<td>output</td>
<td></td>
<td>MDU运算开始</td>
</tr>
<tr>
<td>MDUBusy</td>
<td>output</td>
<td></td>
<td>MDU运算进行（发给Conflict判断阻塞)</td>
</tr>
<tr>
<td>E_HI</td>
<td></td>
<td>[31:0]</td>
<td>待转发的E级MDU的HI结果</td>
</tr>
<tr>
<td>E_LO</td>
<td></td>
<td>[31:0]</td>
<td>待转发的E级MDU的LO结果</td>
</tr>
<tr>
<td><strong>EMReg</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>M_PC</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;E_PC</td>
</tr>
<tr>
<td>M_Ins</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;E_Ins</td>
</tr>
<tr>
<td>M_ALU_Y</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;E_ALU_Y</td>
</tr>
<tr>
<td>M_rt_data</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;<strong>&#x3D;E_rt_fw</strong></td>
</tr>
<tr>
<td>M_branchTrue</td>
<td>output</td>
<td>reg</td>
<td>&lt;&#x3D;E_branchTrue</td>
</tr>
<tr>
<td>M_HI</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;E_HI</td>
</tr>
<tr>
<td>M_LO</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;E_LO</td>
</tr>
</tbody></table>
<ul>
<li>#####E_ALU</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>op</td>
<td>input</td>
<td>[3:0]</td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>Y</td>
<td>output</td>
<td>[31:0]</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>#####E_MDU</p>
<ul>
<li>当指令为mthi, mtlo，将寄存器数据写入HI, LO时，始终上升沿直接给HI, LO赋为A</li>
<li>当为其余四条运算指令时，设置临时计数变量cnt，初始为0，接受到Start信号时，开始设置Busy为1；根据MDU功能选择编码，分别直接计算出HI, LO对应结果赋值，因为其他乘除操作已被阻塞，不会提前读取或写入；设置cnt为5或10，每周期-1，cnt&#x3D;&#x3D;1代表运算结束，持续保持Busy为5&#x2F;10周期后将cnt, Busy归零。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Start</td>
<td>input</td>
<td></td>
<td>CU传入开始乘除运算信号</td>
</tr>
<tr>
<td>MDUSelect</td>
<td>input</td>
<td>[2:0]</td>
<td>CU传入乘除功能选择</td>
</tr>
<tr>
<td>A</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>Busy</td>
<td>output</td>
<td>reg</td>
<td>正在运算信号</td>
</tr>
<tr>
<td>HI</td>
<td>output</td>
<td>reg [31:0]</td>
<td></td>
</tr>
<tr>
<td>LO</td>
<td>output</td>
<td>reg [31:0]</td>
<td></td>
</tr>
</tbody></table>
<h4 id="4-Memory"><a href="#4-Memory" class="headerlink" title="4. Memory"></a>4. Memory</h4><ul>
<li>包括M_CU, M_DE</li>
<li>因储存器外置，删除DM，加入对字节存取数据的操作，包括通过控制四位ByteEn各位</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>M_PC</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>M_Ins</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td><strong>Conflict&#x2F;Forward</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>M_branchTrue</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>M_Tnew</td>
<td>output</td>
<td>[1:0]</td>
<td>AT算阻塞</td>
</tr>
<tr>
<td>M_GRF_WA</td>
<td>output</td>
<td>[4:0]</td>
<td>M级指令写寄存器编号</td>
</tr>
<tr>
<td>M_GRF_WD</td>
<td>output</td>
<td>[31:0]</td>
<td>M级指令写寄存器数据</td>
</tr>
<tr>
<td>M_rt</td>
<td>output</td>
<td>[4:0]</td>
<td>M级指令读寄存器编号</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GRF_WDSrc</td>
<td></td>
<td>[2:0]</td>
<td>M级指令写寄存器数据选择</td>
</tr>
<tr>
<td>MFSelect</td>
<td></td>
<td>[1:0]</td>
<td>读HI LO功能选择</td>
</tr>
<tr>
<td>M_HI</td>
<td>input</td>
<td>[31:0]</td>
<td>待转发的E级MDU的HI结果</td>
</tr>
<tr>
<td>M_LO</td>
<td>input</td>
<td>[31:0]</td>
<td>待转发的E级MDU的LO结果</td>
</tr>
<tr>
<td>M_ALU_Y</td>
<td>input</td>
<td>[31:0]</td>
<td>待转发的E级ALU计算结果</td>
</tr>
<tr>
<td><strong>M_BE</strong>（ByteEnable）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>lowAddr</td>
<td></td>
<td>[1:0]</td>
<td>&#x3D;M_ALU_Y[1:0]，DM写入地址地两位</td>
</tr>
<tr>
<td>M_rt_fw</td>
<td>input</td>
<td>[31:0]</td>
<td>M级接收转发后将写入DM的数据</td>
</tr>
<tr>
<td>ByteSelect</td>
<td></td>
<td>[1:0]</td>
<td>CU访存数据类型选择</td>
</tr>
<tr>
<td>MemWrite</td>
<td></td>
<td></td>
<td>DM写使能</td>
</tr>
<tr>
<td>ByteEn</td>
<td>output</td>
<td>reg [3:0]</td>
<td>控制每一位是否读写的信号输出</td>
</tr>
<tr>
<td>M_DM_WD</td>
<td>output</td>
<td>reg [31:0]</td>
<td></td>
</tr>
<tr>
<td><strong>M_DE</strong>（DataExtend）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>DESelect</td>
<td></td>
<td>[2:0]</td>
<td>字节数据拓展类型</td>
</tr>
<tr>
<td>M_DM_RDin</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>M_DM_RDout</td>
<td></td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td><strong>MWReg</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>W_PC</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;M_PC</td>
</tr>
<tr>
<td>W_Ins</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;M_Ins</td>
</tr>
<tr>
<td>W_ALU_Y</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;M_ALU_Y</td>
</tr>
<tr>
<td>W_DM_RD</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;M_DM_RDout</td>
</tr>
<tr>
<td>W_branchTrue</td>
<td>output</td>
<td>reg</td>
<td>&lt;&#x3D;M_branchTrue</td>
</tr>
<tr>
<td>W_HI</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;M_HI</td>
</tr>
<tr>
<td>W_LO</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;M_LO</td>
</tr>
</tbody></table>
<ul>
<li><h5 id="M-BE（计算字节访存使能，调整四字节写入数据）"><a href="#M-BE（计算字节访存使能，调整四字节写入数据）" class="headerlink" title="M_BE（计算字节访存使能，调整四字节写入数据）"></a>M_BE（计算字节访存使能，调整四字节写入数据）</h5><ul>
<li><p>合并在Memory中，在写入的条件下，根据写入数据类型和写入地址低两位产生四个字节的每一位控制信号，即四位ByteEn</p>
<img src="image-20230311001222299.png" alt="image-20230311001222299" style="zoom:67%;" />
</li>
<li><p>后续再根据ByteEn调整将写入内存的数据，需将待写入的字节移动到对应为En1的位置</p>
<img src="image-20230311001240021.png" alt="image-20230311001240021" style="zoom:67%;" /></li>
</ul>
</li>
<li><h5 id="M-DE（调整内存读出数据，截取需要的字节后拓展）"><a href="#M-DE（调整内存读出数据，截取需要的字节后拓展）" class="headerlink" title="M_DE（调整内存读出数据，截取需要的字节后拓展）"></a>M_DE（调整内存读出数据，截取需要的字节后拓展）</h5><ul>
<li><p>注意DESelect种类编码，注意需要将读出字节移动至低位，高位进行拓展补齐</p>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>lowAddr</td>
<td>input</td>
<td>[1:0]</td>
<td></td>
</tr>
<tr>
<td>DESelect</td>
<td>input</td>
<td>[2:0]</td>
<td></td>
</tr>
<tr>
<td>in</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>out</td>
<td>output</td>
<td>[31:0]</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<img src="image-20230311001304148.png" alt="image-20230311001304148" style="zoom:67%;" />

<ul>
<li>M级与内存数据交换</li>
</ul>
<img src="image-20230311001314893.png" alt="image-20230311001314893" style="zoom:67%;" />

<h4 id="5-Writeback"><a href="#5-Writeback" class="headerlink" title="5. Writeback"></a>5. Writeback</h4><ul>
<li>包括W_CU</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>W_Ins</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>W_PC</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td><strong>Conflict&#x2F;Forward</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>W_branchTrue</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>W_GRF_WA</td>
<td>output</td>
<td>[4:0]</td>
<td>W级指令写寄存器编号</td>
</tr>
<tr>
<td>GRF_WDSrc</td>
<td></td>
<td>[2:0]</td>
<td>W级指令写寄存器数据选择</td>
</tr>
<tr>
<td>MFSelect</td>
<td></td>
<td>[1:0]</td>
<td>读HI LO功能选择</td>
</tr>
<tr>
<td>W_ALU_Y</td>
<td>input</td>
<td>[31:0]</td>
<td>待转发的E级ALU计算结果</td>
</tr>
<tr>
<td>W_DM_RD</td>
<td>input</td>
<td>[31:0]</td>
<td>待转发的M级DM读出数据</td>
</tr>
<tr>
<td>W_HI</td>
<td>input</td>
<td>[31:0]</td>
<td>待转发的E级MDU的HI结果</td>
</tr>
<tr>
<td>W_LO</td>
<td>input</td>
<td>[31:0]</td>
<td>待转发的E级MDU的LO结果</td>
</tr>
<tr>
<td>W_GRF_WD</td>
<td>output</td>
<td>[31:0]</td>
<td>W级指令写寄存器数据</td>
</tr>
</tbody></table>
<h2 id="测试-同P5，P6单独构造测试数据"><a href="#测试-同P5，P6单独构造测试数据" class="headerlink" title="测试(同P5，P6单独构造测试数据)"></a>测试(同P5，P6单独构造测试数据)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">                                        # 13</span><br><span class="line">    ori     $t0,    $0,         0xadce</span><br><span class="line">    sw      $t0,    12($0)</span><br><span class="line">    ori     $t1,    $t0,        0xdefa</span><br><span class="line">    sw      $t1,    8($0)</span><br><span class="line"></span><br><span class="line">    ori     $t3,    $0,         4</span><br><span class="line">    lw      $t2,    8($t3)</span><br><span class="line">    add     $t4,    $t2,        $t0</span><br><span class="line"></span><br><span class="line">    ori     $t3,    $0,         15</span><br><span class="line">    lw      $t4,    -7($t3)</span><br><span class="line">    sub     $t5,    $t4,        $t2</span><br><span class="line"></span><br><span class="line"># 14</span><br><span class="line">    ori     $t0,    $0,         0xefac</span><br><span class="line">    sw      $t0,    12($0)</span><br><span class="line">    ori     $t1,    $t0,        0xfead</span><br><span class="line">    sw      $t1,    8($0)</span><br><span class="line"></span><br><span class="line">    ori     $t3,    $0,         4</span><br><span class="line">    lw      $t2,    8($t3)</span><br><span class="line">    add     $t4,    $t0,        $t2</span><br><span class="line"></span><br><span class="line">    ori     $t3,    $0,         21</span><br><span class="line">    lw      $t4,    -13($t3)</span><br><span class="line">    sub     $t5,    $t2,        $t4</span><br><span class="line"></span><br><span class="line"># 15</span><br><span class="line">    ori     $t0,    $0,         0x0ace</span><br><span class="line">    sw      $t0,    12($0)</span><br><span class="line">    ori     $t1,    $t0,        0x00a1</span><br><span class="line">    sw      $t1,    8($0)</span><br><span class="line"></span><br><span class="line">    ori     $t3,    $0,         4</span><br><span class="line">    lw      $t2,    8($t3)</span><br><span class="line">    nop     </span><br><span class="line">    add     $t4,    $t2,        $t0</span><br><span class="line"></span><br><span class="line">    ori     $t3,    $0,         15</span><br><span class="line">    lw      $t4,    -7($t3)</span><br><span class="line">    nop     </span><br><span class="line">    sub     $t5,    $t4,        $t2</span><br><span class="line"></span><br><span class="line"># 16</span><br><span class="line">    lui     $t0,    0x1234</span><br><span class="line">    sw      $t0,    12($0)</span><br><span class="line">    lui     $t1,    0xfead</span><br><span class="line">    sw      $t1,    8($0)</span><br><span class="line"></span><br><span class="line">    ori     $t3,    $0,         4</span><br><span class="line">    lw      $t2,    8($t3)</span><br><span class="line">    nop     </span><br><span class="line">    add     $t4,    $t0,        $t2</span><br><span class="line"></span><br><span class="line">    ori     $t3,    $0,         25</span><br><span class="line">    lw      $t4,    -17($t3)</span><br><span class="line">    nop     </span><br><span class="line">    sub     $t5,    $t2,        $t4</span><br><span class="line"></span><br><span class="line"># 17</span><br><span class="line">    lui     $1,     0x13ac</span><br><span class="line">    ori     $2,     0x12ae</span><br><span class="line"></span><br><span class="line">    add     $3,     $1,         $2</span><br><span class="line">    ori     $4,     $3,         0xcd12</span><br><span class="line"></span><br><span class="line">    sub     $5,     $4,         $1</span><br><span class="line">    ori     $6,     $5,         0x4589</span><br><span class="line"></span><br><span class="line"># 18</span><br><span class="line">    lui     $1,     0x56ed</span><br><span class="line">    ori     $2,     0x349a</span><br><span class="line"></span><br><span class="line">    add     $3,     $1,         $2</span><br><span class="line">    nop     </span><br><span class="line">    ori     $4,     $3,         0xc102</span><br><span class="line"></span><br><span class="line">    sub     $5,     $4,         $1</span><br><span class="line">    nop     </span><br><span class="line">    ori     $6,     $5,         0x4ea9</span><br><span class="line"></span><br><span class="line"># 19</span><br><span class="line">    lui     $7,     0x1345</span><br><span class="line">    ori     $8,     $7,         0x1122</span><br><span class="line"></span><br><span class="line">    ori     $9,     $8,         0x3344</span><br><span class="line">    ori     $10,    $9,         0x00ff</span><br><span class="line"></span><br><span class="line"># 20</span><br><span class="line">    lui     $7,     0x2211</span><br><span class="line">    nop     </span><br><span class="line">    ori     $8,     $7,         0x3366</span><br><span class="line">    nop     </span><br><span class="line">    ori     $9,     $8,         0xf111</span><br><span class="line">    nop     </span><br><span class="line">    ori     $10,    $9,         0x00ff</span><br><span class="line"></span><br><span class="line"># 21</span><br><span class="line">    jal     label1</span><br><span class="line">    ori     $8,     $ra,        0x8899</span><br><span class="line">    nop     </span><br><span class="line">    nop     </span><br><span class="line">label1:</span><br><span class="line">                                        # 22</span><br><span class="line">    jal     label2</span><br><span class="line">    nop     </span><br><span class="line">    nop     </span><br><span class="line">    nop     </span><br><span class="line">    nop     </span><br><span class="line">label2:</span><br><span class="line">    ori     $9,     $ra,        0xaa12</span><br><span class="line">                                        # 23</span><br><span class="line">    ori     $t0,    $0,         35</span><br><span class="line">    sw      $ra,    24($0)</span><br><span class="line">    lw      $t1,    -11($t0)</span><br><span class="line">    ori     $t2,    $t1,        0xe2df</span><br><span class="line"></span><br><span class="line"># 24</span><br><span class="line">    sw      $t2,    36($0)</span><br><span class="line">    lw      $t3,    1($t0)</span><br><span class="line">    nop     </span><br><span class="line">    ori     $t4,    $t3,        0xaabb</span><br></pre></td></tr></table></figure>

<img src="image-20230311001334635.png" alt="image-20230311001334635" style="zoom:67%;" />

<ul>
<li>对0号寄存器读写测试</li>
</ul>
<img src="image-20230311001346059.png" alt="image-20230311001346059" style="zoom:67%;" />

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>乘除指令的Tuse，Tnew：包括md指令Tuse_rs&#x3D;Tuse_rt&#x3D;1; mf指令E_Tnew&#x3D;1</li>
<li>按字节访存的字节位置调整</li>
<li>指令功能选择编码</li>
<li>cal_i指令拓展类型，有有符号，有无符号</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>因为硬件运算中乘除法消耗时间很长，需要持续多个周期，放入ALU后会大幅降低频率。独立的HI，LO寄存器方便乘除槽与外部交换数据，并且单独预留给乘除指令，避免其他普通存取导致过多阻塞。</li>
<li>使用移位操作，采用逐位并行的迭代阵列结构，将每个操作数的N位都并行地提交给乘法器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module multi_4bits_pipelining(mul_a, mul_b, clk, rst_n, mul_out);</span><br><span class="line">    input [3:0] mul_a, mul_b;</span><br><span class="line">    input clk;</span><br><span class="line">    input rst_n;</span><br><span class="line">    output [15:0] mul_out;</span><br><span class="line"> </span><br><span class="line">    reg [15:0] mul_out;</span><br><span class="line">    reg [15:0] stored0;</span><br><span class="line">    reg [15:0] stored1;</span><br><span class="line">    reg [15:0] stored2;</span><br><span class="line">    reg [15:0] stored3;</span><br><span class="line">    reg [15:0] stored4;</span><br><span class="line">    reg [15:0] stored5;</span><br><span class="line">    reg [15:0] stored6;</span><br><span class="line">    reg [15:0] stored7;</span><br><span class="line"> </span><br><span class="line">    reg [15:0] mul_out01;</span><br><span class="line">    reg [15:0] mul_out23;</span><br><span class="line"> </span><br><span class="line">    reg [15:0] add01;</span><br><span class="line">    reg [15:0] add23;</span><br><span class="line">    reg [15:0] add45;</span><br><span class="line">    reg [15:0] add67;</span><br><span class="line"> </span><br><span class="line">    always @(posedge clk or negedge rst_n) begin</span><br><span class="line">        if(!rst_n) begin</span><br><span class="line">            mul_out &lt;= 0;</span><br><span class="line">            stored0 &lt;= 0;</span><br><span class="line">            stored1 &lt;= 0;</span><br><span class="line">            stored2 &lt;= 0;</span><br><span class="line">            stored3 &lt;= 0;</span><br><span class="line">            stored4 &lt;= 0;</span><br><span class="line">                    stored5 &lt;= 0;</span><br><span class="line">            stored6 &lt;= 0;</span><br><span class="line">            stored7 &lt;= 0;</span><br><span class="line"> </span><br><span class="line">            add01 &lt;= 0;</span><br><span class="line">            add23 &lt;= 0;</span><br><span class="line">            add45 &lt;= 0;</span><br><span class="line">            add67 &lt;= 0;</span><br><span class="line">    end</span><br><span class="line">    else begin</span><br><span class="line">        stored0 &lt;= mul_b[0]? &#123;8&#x27;b0, mul_a&#125; : 16&#x27;b0;</span><br><span class="line">        stored1 &lt;= mul_b[1]? &#123;7&#x27;b0, mul_a, 1&#x27;b0&#125; : 16&#x27;b0;</span><br><span class="line">        stored2 &lt;= mul_b[2]? &#123;6&#x27;b0, mul_a, 2&#x27;b0&#125; : 16&#x27;b0;</span><br><span class="line">        stored3 &lt;= mul_b[3]? &#123;5&#x27;b0, mul_a, 3&#x27;b0&#125; : 16&#x27;b0;</span><br><span class="line">        stored4 &lt;= mul_b[0]? &#123;4&#x27;b0, mul_a, 4&#x27;b0&#125; : 16&#x27;b0;</span><br><span class="line">        stored5 &lt;= mul_b[1]? &#123;3&#x27;b0, mul_a, 5&#x27;b0&#125; : 16&#x27;b0;</span><br><span class="line">        stored6 &lt;= mul_b[2]? &#123;2&#x27;b0, mul_a, 6&#x27;b0&#125; : 16&#x27;b0;</span><br><span class="line">        stored7 &lt;= mul_b[3]? &#123;1&#x27;b0, mul_a, 7&#x27;b0&#125; : 16&#x27;b0;</span><br><span class="line">        add01 &lt;= stored1 + stored0;</span><br><span class="line">        add23 &lt;= stored3 + stored2;</span><br><span class="line">        add45 &lt;= stored5 + stored4;</span><br><span class="line">        add67 &lt;= stored7 + stored6;</span><br><span class="line"> </span><br><span class="line">        mul_out01 &lt;= add01 + add23;</span><br><span class="line">        mul_out23 &lt;= add45 + add67;</span><br><span class="line"> </span><br><span class="line">        mul_out &lt;= mul_out01 + mul_out23;</span><br><span class="line"> </span><br><span class="line">    end</span><br><span class="line">    end</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>在Start到来的周期开始置1，通过cnt计数周期，计数完毕前始终保持1，完毕后归0</p>
</li>
<li><p>统一所有三种数据类型的访存操作，避免使用过多控制信号。直接用对应字节是否Enable决定是否访存，更加直接清晰。</p>
</li>
<li><p>在lb,sb的情况下是一个字节；lh,sh两个字节；lw,sw四个字节。而按字访存的情况下则始终操作四个字节所以在执行lh,sh,lb,sb指令时按字节读和按字节写的效率会高于按字读和按字写。</p>
</li>
<li><p>将指令分类，译码时不用在每个控制信号与AT计算中添加新指令，便于管理与增量开发，但需要注意某些功能是否相同，具有统一行为，如EXT。采用分布式统一译码，将各级所需控制信号直接独立传递。</p>
</li>
<li><ul>
<li><p>MDU的指令之间的冲突：在D级检测是否该指令要使用MDU，暂停的条件是要使用MDU并且MDU处于start或busy的状态。</p>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ori $t1,5</span><br><span class="line">mthi $t1</span><br><span class="line">mtlo $t1</span><br><span class="line">div $t1,$t2</span><br><span class="line">mfhi $t4</span><br><span class="line">mflo $t5</span><br><span class="line">div $t2,$t3</span><br><span class="line">mfhi $t4</span><br><span class="line">mflo $t5</span><br></pre></td></tr></table></figure>
</li>
<li><p>MDU与其他指令的冲突：包括md指令Tuse_rs&#x3D;Tuse_rt&#x3D;1; mf指令E_Tnew&#x3D;1</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">here:</span><br><span class="line">ori $t1,5</span><br><span class="line">sw $t1,0($0)</span><br><span class="line">lw $t2,0($0)</span><br><span class="line">div $t1,$t2</span><br><span class="line">mfhi $t3</span><br><span class="line">mflo $t4</span><br><span class="line">beq $t4,$5,here</span><br></pre></td></tr></table></figure>
</li>
<li><p>除MDU之外其他指令之间的冲突：指令分类后用指令类型设定对应的Tuse和Tnew，与P5相同</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ori $t0,5</span><br><span class="line">lui $t1,1</span><br><span class="line">sw $t1,0($0)</span><br><span class="line">lbu $t2,0($0)</span><br><span class="line">or $t3,$t1,$t2</span><br><span class="line">lh $t5,0($0)</span><br><span class="line">slt $t6,$t4,$t5</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>测试单条指令</p>
</li>
<li><p>枚举各指令排列和之间距离</p>
</li>
<li><p>枚举各个寄存器访存，以及HI, LO</p>
</li>
<li><p>枚举各种数据类型和数据的读写</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Computer Orgnization</category>
      </categories>
      <tags>
        <tag>Computer Orgnization</tag>
      </tags>
  </entry>
  <entry>
    <title>P7设计文档</title>
    <url>/2023/03/10/19-16-54/</url>
    <content><![CDATA[<h2 id="5级流水线CPU设计文档-中断支持"><a href="#5级流水线CPU设计文档-中断支持" class="headerlink" title="5级流水线CPU设计文档+中断支持"></a>5级流水线CPU设计文档+中断支持</h2><span id="more"></span>
<h2 id="支持指令"><a href="#支持指令" class="headerlink" title="支持指令"></a>支持指令</h2><p>  <strong>R, add, sub, And, Or, Xor, slt, sltu</strong></p>
<p>  <strong>addi, andi, xori, ori, lui</strong></p>
<p>  <strong>lb, lh, lw, sb, sh, sw, lbu, lhu</strong></p>
<p>  <strong>mult, multu, div, divu, mfhi, mflo, mthi, mtlo</strong></p>
<p>  <strong>beq, bne, j, jal, jr, bltzal</strong></p>
<p> <strong>nop, eret, mtc0, mfc0, syscall</strong></p>
<h2 id="流程模块设计"><a href="#流程模块设计" class="headerlink" title="流程模块设计"></a>流程模块设计</h2><img src="image-20230311001413097.png" alt="image-20230311001413097" style="zoom:67%;" />

<h3 id="CP0"><a href="#CP0" class="headerlink" title="CP0"></a>CP0</h3><ul>
<li>处理来自CPU的内部异常以及来自中断发生器与timer的外部中断，产生异常控制信号给CPU</li>
<li>放置在M级，接收CPU在M级的mtc0,mfc0,eret指令</li>
<li>其中包含三个寄存器SR、Cause、EPC，SR为中断异常使能控制，Cause为异常中断情况，EPC为异常处理结束后需要返回的PC</li>
<li>具体SR、Cause的特定位如下宏定义所示，后续控制逻辑由其产生</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`define IM SR[15:10]        //Interrupt Mask 由mtc0修改，屏蔽中断</span><br><span class="line">`define EXL SR[1]           //Exception Level 表明进入中断异常，禁止所有中断和异常</span><br><span class="line">`define IE SR[0]            //Interrupt Enable 全局中断使能(不影响异常)</span><br><span class="line">`define BD Cause[31]        //Branch Delay EPC是否指向前一条（延迟槽）指令</span><br><span class="line">`define IP Cause[15:10]     //Interrupt Pending 表明6个外部中断有无，由计时器和外部中断修改</span><br><span class="line">`define ExcCode Cause[6:2]  //ExcCode 异常编码，记录当前发生的是什么异常。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过EXL和ExcCodeIn判断有无异常产生，通过EXL和IE，以及每一位有没有既有中断使能，又有中断信号判断有无中断产生。</p>
</li>
<li><p>注意产生异常或中断时指令在延迟槽，返回PC应为到上一条跳转指令的PC，需要从D级一直流水BDIn信号，tmp_EPC &#x3D; Req?(BDIn?VPC-4:VPC):EPC</p>
</li>
<li><p>其中VPC为M级PC，即在外界观察到的宏观PC</p>
</li>
<li><p>写寄存器只可写SR以及EPC，判断写入地址是否是12或14并且有写使能</p>
</li>
<li><p>读寄存器可以直接读，根据地址12 13 14读三个寄存器</p>
</li>
<li><p>端口</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>en</td>
<td>input</td>
<td></td>
<td>写使能信号 (mtc0)</td>
</tr>
<tr>
<td>CP0Add</td>
<td>input</td>
<td>[4:0]</td>
<td>读写寄存器的编号</td>
</tr>
<tr>
<td>CP0In</td>
<td>input</td>
<td>[31:0]</td>
<td>CP0写入数据</td>
</tr>
<tr>
<td>CP0Out</td>
<td>output</td>
<td>[31:0]</td>
<td>CP0读出数据</td>
</tr>
<tr>
<td>VPC</td>
<td>input</td>
<td>[31:0]</td>
<td>受害PC</td>
</tr>
<tr>
<td>BDIn</td>
<td>input</td>
<td></td>
<td>是否是延迟槽指令</td>
</tr>
<tr>
<td>EPCOUt</td>
<td>output</td>
<td>[31:0]</td>
<td>EPC的值</td>
</tr>
<tr>
<td>EXLClr</td>
<td>input</td>
<td></td>
<td>用来复位EXL（M级指令是eret，即退出异常）</td>
</tr>
<tr>
<td>ExcCodeIn</td>
<td>input</td>
<td>[4:0]</td>
<td>记录异常类型</td>
</tr>
<tr>
<td>HWInt</td>
<td>input</td>
<td>[5:0]</td>
<td>输入6个设备中断信号</td>
</tr>
<tr>
<td>Req</td>
<td>output</td>
<td></td>
<td>进入处理程序请求（有异常或中断）</td>
</tr>
</tbody></table>
<h3 id="系统桥"><a href="#系统桥" class="headerlink" title="系统桥"></a>系统桥</h3><ul>
<li>对CPU向外设写入的数据进行分流，对外设向CPU写入的数据进行选择。</li>
</ul>
<img src="image-20230311001425849.png" alt="image-20230311001425849" width="67%" height="67%" />

<ul>
<li>CPU从外设读：根据地址用MUX筛选；CPU向外设写：写地址、数据直接全部发送，写使能用byteen以及写地址决定决定</li>
<li>修改层级结构，在最高层通过系统桥将CPU与外置DM,TC0,TC1,以及中断生成器相连</li>
<li>注意传给DM的按位读写使能要再读写其他外设时置为0</li>
<li>端口：</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>CPUAddr</td>
<td>input</td>
<td>[31:0]</td>
<td>CPU读写地址</td>
</tr>
<tr>
<td>CPUWD</td>
<td>input</td>
<td>[31:0]</td>
<td>CPU往外设写数据</td>
</tr>
<tr>
<td>CPUbyteen</td>
<td>input</td>
<td>[3:0]</td>
<td>按位读写使能</td>
</tr>
<tr>
<td>TC0Write</td>
<td>output</td>
<td></td>
<td>写TC0</td>
</tr>
<tr>
<td>TC1Write</td>
<td>output</td>
<td></td>
<td>写TC1</td>
</tr>
<tr>
<td>DEV_Addr</td>
<td>output</td>
<td>[31:0]</td>
<td>往外设写入的地址</td>
</tr>
<tr>
<td>DEV_WD</td>
<td>output</td>
<td>[31:0]</td>
<td>往外设写入的数据</td>
</tr>
<tr>
<td>temp_m_data_byteen</td>
<td>output</td>
<td>[3:0]</td>
<td>传给DM的按位读写使能</td>
</tr>
<tr>
<td>DMRD</td>
<td>input</td>
<td>[31:0]</td>
<td>三个外设写入CPU的数据</td>
</tr>
<tr>
<td>TC0RD</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>TC1RD</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>CPURD</td>
<td>output</td>
<td>[31:0]</td>
<td>最后决定写入CPU的数据</td>
</tr>
</tbody></table>
<h3 id="TC"><a href="#TC" class="headerlink" title="TC"></a>TC</h3><ul>
<li><p>包含三个32位寄存器，ctrl, preset, count</p>
</li>
<li><p>ctrl[3]表示中断屏蔽（1允许中断），[2:1]为模式选择，[0]为计数器使能</p>
</li>
<li><p>四个状态的状态机，在INT状态下，如果中断没有屏蔽，则向外发送中断信号</p>
<ul>
<li>idle状态下，如果计数器使能为1则转至load状态</li>
<li>load状态下，加载初始值之后转至cnt状态</li>
<li>cnt状态下，如计数器使能为1则开始倒计数，cnt&#x3D;&#x3D;0之后产生一周期终端信号，状态变为interrupt；如果计数器使能为0，则回到idle</li>
<li>interrupt状态下，如果在模式0，计数到0时计数器使能变0；如果在模式1，计数为0时中断变0。之后回到idle，等待计数器使能变1往复</li>
</ul>
</li>
<li><p>端口</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Addr</td>
<td>input</td>
<td>[31:2]</td>
<td></td>
</tr>
<tr>
<td>WE</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Din</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>Dout</td>
<td>output</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>IRQ</td>
<td>output</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="内部异常设计"><a href="#内部异常设计" class="headerlink" title="内部异常设计"></a>内部异常设计</h3><ul>
<li><p>所有异常级别低于中断级别，并均低于Reset</p>
</li>
<li><p>每一级的异常流水需要遵循距离M级远的优先级更高，即在上一级有异常时，按上一级往后传；没有异常时，再判断当前阶段有无异常。</p>
</li>
<li><p>F级有F_Exc_AdEL，取指令异常，即取地址低位没有对齐或者超出地址存储区域。注意在有eret信号时，直接跳转到中断处理程序，不产生异常。</p>
</li>
<li><p>D级D_Exc_RI，即未知指令与D_Exc_syscall，即syscall指令，从CU增加两个控制信号即可。</p>
</li>
<li><p>E级有E_Exc_AriOv，即计算指令溢出。同时还可产生E_Exc_DMOv，即地址指令溢出，但需要注意该异常需要在M级才真正出现，E级只是提前计算，访存指令还未执行，需要跳过E级异常流水，直接传给M级再加入异常流水判断。</p>
</li>
<li><p>M级有M_Exc_AdES与M_Exc_AdEL，即写入地址错误与读出地址错误。注意除了地址不对齐、超出范围之外，还有M级的地址运算溢出，<strong>以及不可用lb,lh读写timer中三个寄存器和不可写timer中count寄存器的要求</strong>。</p>
</li>
<li><p>最后传至CP0的即M级的ExcCode</p>
</li>
</ul>
<h3 id="CU模块设计"><a href="#CU模块设计" class="headerlink" title="CU模块设计"></a>CU模块设计</h3><ul>
<li>相较P4，省去RegWrite信号，直接译出当前指令需要写入的地址，如不需写入，默认写至0，在写入GRF时直接略去</li>
<li>直接译出当前指令rs, rt, rd, shamt, imm16, imm26以及所有控制信号供每个阶段选取使用，还需译出Tuse_rs&#x2F;rt以及E_Tnew与M_Tnew，各级输出对应信号至Conflict模块</li>
<li>将指令分类，分为：cal_r,cal_i,md,mt,mf,load,save,branch,branch_ucl,branch_cl,shift,jreg,jadd,jlink（ori被归为cal_i）</li>
<li>增加四个指令，增加GRF写入数据来源、写入地址的选择</li>
<li>增加ALUDM、ALUAri输出端口，表示当前使用ALU计算的指令是地址访存指令还是计算指令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   assign cal_r=(add||sub||And||Or||Xor||slt||sltu);</span><br><span class="line">assign cal_i=(addi||andi||xori||ori||lui);</span><br><span class="line"></span><br><span class="line">   assign md   =(mult||multu||div||divu);</span><br><span class="line">   assign mf   =(mfhi||mflo);</span><br><span class="line">   assign mt   =(mthi||mtlo);</span><br><span class="line"></span><br><span class="line">assign load=(lw||lh||lhu||lb||lbu);</span><br><span class="line">assign save=(sw||sh||sb);</span><br><span class="line"></span><br><span class="line">   assign branch=(beq||bne||branch_ucl||branch_cl);</span><br><span class="line">   assign branch_ucl=bltzal;</span><br><span class="line">   assign branch_cl=0;</span><br><span class="line"></span><br><span class="line">   assign jreg = jr;</span><br><span class="line">   assign jadd = (j||jal);</span><br><span class="line">   assign jlink = jal;</span><br><span class="line"></span><br><span class="line">   assign shift=sll;</span><br></pre></td></tr></table></figure>

<ul>
<li>控制信号新增：MDU, MDUStart, MDUSelect, MFSelect, ByteSelect, DESelect</li>
<li>控制信号调整：GRF_WA, GRF_WDSrc, ALUSelect, <strong>EXTSelect（cal_i各个指令行为不同，注意对照指令集）</strong>,BranchSelect</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Ins</td>
<td>input</td>
<td>[31:0]</td>
<td>当级指令</td>
</tr>
<tr>
<td>branchTrue</td>
<td>input</td>
<td></td>
<td>分支控制信号</td>
</tr>
<tr>
<td><strong>控制信号</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GRF_WA</td>
<td>output</td>
<td>[4:0]</td>
<td>写入的地址</td>
</tr>
<tr>
<td>GRF_WDSrc</td>
<td>output</td>
<td>[2:0]</td>
<td>写入数据选择</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>EXTSelect</td>
<td>output</td>
<td></td>
<td>EXT位拓展类型选择</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ALUSrc</td>
<td>output</td>
<td></td>
<td>ALU_B的数据源选择</td>
</tr>
<tr>
<td>ALUSelect</td>
<td>output</td>
<td>[3:0]</td>
<td>ALU运算类型选择</td>
</tr>
<tr>
<td><u>MDU</u></td>
<td>output</td>
<td></td>
<td>乘除运算+读写HI LO信号（需要阻塞）</td>
</tr>
<tr>
<td><u>MDUStart</u></td>
<td>output</td>
<td></td>
<td>乘除运算开始信号</td>
</tr>
<tr>
<td><u>MDUSelect</u></td>
<td>output</td>
<td>[2:0]</td>
<td>乘除运算+写HI LO功能选择</td>
</tr>
<tr>
<td><u>MFSelect</u></td>
<td>output</td>
<td>[1:0]</td>
<td>读HI LO功能选择</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>MemWrite</td>
<td>output</td>
<td></td>
<td>内存写入控制</td>
</tr>
<tr>
<td>BranchSelect</td>
<td>output</td>
<td>[3:0]</td>
<td>branch判断类型选择</td>
</tr>
<tr>
<td>NPCSelect</td>
<td>output</td>
<td>[2:0]</td>
<td>NPC类型选择</td>
</tr>
<tr>
<td><u>ByteSelect</u></td>
<td>output</td>
<td>[1:0]</td>
<td>访存数据类型选择</td>
</tr>
<tr>
<td><u>DESelect</u></td>
<td>output</td>
<td>[2:0]</td>
<td>读取内存后结果拓展类型</td>
</tr>
<tr>
<td><strong>指令译码</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>opcode</td>
<td>output</td>
<td>[5:0]</td>
<td></td>
</tr>
<tr>
<td>funct</td>
<td>output</td>
<td>[5:0]</td>
<td></td>
</tr>
<tr>
<td>rs</td>
<td>output</td>
<td>[4:0]</td>
<td></td>
</tr>
<tr>
<td>rt</td>
<td>output</td>
<td>[4:0]</td>
<td></td>
</tr>
<tr>
<td>rd</td>
<td>output</td>
<td>[4:0]</td>
<td></td>
</tr>
<tr>
<td>shamt</td>
<td>output</td>
<td>[4:0]</td>
<td></td>
</tr>
<tr>
<td>imm16</td>
<td>output</td>
<td>[15:0]</td>
<td></td>
</tr>
<tr>
<td>imm26</td>
<td>output</td>
<td>[25:0]</td>
<td></td>
</tr>
<tr>
<td><strong>T计算</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Tuse_rs</td>
<td>output</td>
<td>[1:0]</td>
<td></td>
</tr>
<tr>
<td>Tuse_rt</td>
<td>output</td>
<td>[1:0]</td>
<td></td>
</tr>
<tr>
<td>E_Tnew</td>
<td>output</td>
<td>[1:0]</td>
<td></td>
</tr>
<tr>
<td>M_Tnew</td>
<td>output</td>
<td>[1:0]</td>
<td></td>
</tr>
</tbody></table>
<h4 id="T计算表格"><a href="#T计算表格" class="headerlink" title="T计算表格"></a>T计算表格</h4><ul>
<li>注意新增的乘除指令的AT</li>
</ul>
<table>
<thead>
<tr>
<th>Ins</th>
<th>Tuse_rs</th>
<th>Tuse_rt</th>
<th>E_Tnew</th>
<th>M_Tnew</th>
</tr>
</thead>
<tbody><tr>
<td>cal_r</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>cal_i</td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
</tr>
<tr>
<td><u>md</u></td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td><u>mt</u></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><u>mf</u></td>
<td></td>
<td></td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>load</td>
<td>2</td>
<td></td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>save</td>
<td>1</td>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>branch</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>jreg</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Conflit模块设计：AT控制阻塞，直接转发"><a href="#Conflit模块设计：AT控制阻塞，直接转发" class="headerlink" title="Conflit模块设计：AT控制阻塞，直接转发"></a>Conflit模块设计：AT控制阻塞，直接转发</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul>
<li>D级判断将要使用的寄存器数据是否能得到转发更新，即后续写入相同寄存器的Tnew是否有大于Tuse的，如果有则需要阻塞，以在后续能得到转发更新。特判0号寄存器不需要阻塞，能够直接获得数据0</li>
<li>需要得到D级指令rs, rt的Tuse，以及后续E, M级指令的Tnew，在各级CU中计算，发送至冲突单元（W级Tnew全是0不需要考虑，都可以内部转发解决）</li>
<li>阻塞时需要暂停更新PC以及F级读出的指令，并且清空D级当前指令的译码输出，以替换为nop空泡</li>
<li>P6新增乘除Stall，在乘除运算即将开始或正在进行时如遇到乘除指令需要Stall</li>
<li>P7新增eret的Stall，eret与mtc0的写后读冲突，需要单独判断阻塞，判断方法为当D级为eret即将读CP0的EPC时，EM级如果有mtc0即将写入CP0的EPC，即rd为14时，阻塞。</li>
</ul>
<img src="image-20230311001016596.png" alt="image-20230311001016596"/>

<h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><ul>
<li><p>阻塞后，所有指令在需要读寄存器数据的时候都能够获得后续计算完毕的数据，每级转发出已算出的数据，发送给之前各级即可。</p>
</li>
<li><p>需要读寄存器：D级GRF，Branch计算需要rs, rt数据；E级ALU需要rs,rt 数据；M级DM写入数据口需要rt数据</p>
</li>
<li><p>需要写寄存器：E级可转发出D级算的PC+8；M级可转发出D级算的PC+8和E级算的的ALU_Y；W级可转发出D级算的PC+8，E级算的的ALU_Y和M级读出的DM数据。<strong>根据当前指令CU译码得到的GRF_WDSrc进行选择</strong>。此外还有W级寄存器写入，可直接内部转发至D级读出</p>
</li>
</ul>
<img src="image-20230311001109169.png" alt="image-20230311001109169" style="zoom:67%;" />

<img src="image-20230311001116883.png" alt="image-20230311001116883" style="zoom:67%;" />

<img src="image-20230311001122673.png" alt="image-20230311001122673" style="zoom:67%;" />

<img src="image-20230311001129478.png" alt="image-20230311001129478" style="zoom:67%;" />

<ul>
<li>在主模块中，获取各级需要读的寄存器编号（D_rs,D_rt,E_rs,E_rt,M_rt），寄存器原读数（D_rs_data,D_rt_data,E_rs_data,E_rt_data,M_rt_data），写入的寄存器编号（E_GRF_WA,M_GRF_WA,W_GRF_WA）和数据（E_GRF_WD,M_GRF_WD,W_GRF_WD）</li>
<li>比较读的编号和写的编号是否有相等的，如有相等的则代表有数据已经更新需要转发，转发优先级为更新次序，最后一次更新优先转发，即优先转发距离需要数据的阶段近的数据，特判如果需要读0号寄存器的数据，直接转发0</li>
<li>转发的数据（D_rs_fw,D_rt_fw,E_rs_fw,E_rt_fw,M_rt_fw）发送至各级需要的部分运算，并传递给下一级</li>
</ul>
<img src="image-20230311001150971.png" alt="image-20230311001150971" style="zoom: 67%;" />

<h3 id="五级模块设计"><a href="#五级模块设计" class="headerlink" title="五级模块设计"></a>五级模块设计</h3><img src="image-20230311001621204.png" alt="image-20230311001621204" style="zoom:80%;" />

<ul>
<li><p>每个阶段之间以寄存器隔开，寄存器设计在每个模块输出处，使用reg类型</p>
</li>
<li><p>每个阶段之间需要流水传递Ins，PC，传给各级CU以译码出当前阶段的rs，rt以及需要写入的地址和写入数据的选择</p>
</li>
<li><p>部分阶段前后间需要传递需要使用的NPC, EXTout, ALU_Y, DM_RD</p>
</li>
<li><p>P7新增：各级传出ExcCode并流水传递以及DS（指令是否在延迟槽中）；CU需在D和M级多译出rd，为对CP0的读写提供阻塞条件与地址</p>
</li>
</ul>
<h4 id="P6更新乘除槽与储存器外置以及按字节访存"><a href="#P6更新乘除槽与储存器外置以及按字节访存" class="headerlink" title="P6更新乘除槽与储存器外置以及按字节访存"></a>P6更新乘除槽与储存器外置以及按字节访存</h4><ul>
<li>删去F_IFU与M_DM，添加M_DE与E_MDU</li>
<li>乘除槽有两个寄存器，其中数据需要在EMW级流水，以便进行转发，并且需要添加转发信号控制</li>
<li>外置储存器需要修改数据通路，前寄存器发送写入数据，后寄存器接收读出数据</li>
</ul>
<h4 id="P7宏观PC"><a href="#P7宏观PC" class="headerlink" title="P7宏观PC"></a>P7宏观PC</h4><ul>
<li><p>在外界的视角，仅需知道当前周期的情况，外界通过给出中断与CPU沟通，中断处理器位于M级，所以M级表现在外，宏观PC为M级PC</p>
</li>
<li><p>为了保证做出单周期的表现，需要在出现异常中断时，所有流水寄存器统一做出跳转到4180中断处理程序的形态，并停止流水线中所有正在执行的指令的行为</p>
</li>
</ul>
<h4 id="1-Fetch"><a href="#1-Fetch" class="headerlink" title="1. Fetch"></a>1. Fetch</h4><ul>
<li>包含FDReg</li>
<li>Fetch</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>F_Flush</td>
<td>input</td>
<td></td>
<td>清空延迟槽信号</td>
</tr>
<tr>
<td>F_Stall</td>
<td>input</td>
<td></td>
<td>阻塞更新PC</td>
</tr>
<tr>
<td>NPC</td>
<td>input</td>
<td>[31:0]</td>
<td>D级NPC计算出的NPC传入</td>
</tr>
<tr>
<td>F_PC</td>
<td><strong>output</strong></td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;NPC，传出至外部指令储存器</td>
</tr>
<tr>
<td>F_Ins</td>
<td><strong>input</strong></td>
<td>[31:0]</td>
<td>需要从外部指令储存器读入Ins</td>
</tr>
<tr>
<td><strong>FD寄存器</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>D_Stall</td>
<td>input</td>
<td></td>
<td>阻塞更新FD间寄存器</td>
</tr>
<tr>
<td>D_Flush</td>
<td>input</td>
<td></td>
<td>清除延迟槽信号</td>
</tr>
<tr>
<td>D_PC</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;F_PC</td>
</tr>
<tr>
<td>D_Ins</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;F_Ins</td>
</tr>
</tbody></table>
<ul>
<li>F级与指令储存的数据交换</li>
</ul>
<img src="image-20230311001208043.png" alt="image-20230311001208043" style="zoom:67%;" />

<h4 id="2-Decode"><a href="#2-Decode" class="headerlink" title="2. Decode"></a>2. Decode</h4><ul>
<li>包括D_CU, EXT, NPC (Branch), DEReg</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>D_PC</td>
<td>input</td>
<td>[31:0]</td>
<td>PC流水</td>
</tr>
<tr>
<td>D_Ins</td>
<td>input</td>
<td>[31:0]</td>
<td>指令流水</td>
</tr>
<tr>
<td><strong>Conflict&#x2F;Forward</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Tuse_rs</td>
<td>output</td>
<td>[1:0]</td>
<td>AT算阻塞</td>
</tr>
<tr>
<td>Tuse_rt</td>
<td>output</td>
<td>[1:0]</td>
<td></td>
</tr>
<tr>
<td>D_rs</td>
<td>output</td>
<td>[4:0]</td>
<td>D级指令读寄存器的编号</td>
</tr>
<tr>
<td>D_rt</td>
<td>output</td>
<td>[4:0]</td>
<td></td>
</tr>
<tr>
<td>D_rs_data</td>
<td>output</td>
<td>[31:0]</td>
<td>D级指令读寄存器原数据</td>
</tr>
<tr>
<td>D_rt_data</td>
<td>output</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>D_rs_fw</td>
<td>input</td>
<td>[31:0]</td>
<td>D级转发后寄存器数据</td>
</tr>
<tr>
<td>D_rt_fw</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td><strong>EXT</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>imm16</td>
<td></td>
<td>[15:0]</td>
<td>EXT输入</td>
</tr>
<tr>
<td>EXTSelect</td>
<td></td>
<td></td>
<td>EXT功能选择</td>
</tr>
<tr>
<td>D_EXT_out</td>
<td></td>
<td>[31:0]</td>
<td>EXT输出</td>
</tr>
<tr>
<td><strong>NPC</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>NPCSelect</td>
<td></td>
<td>[2:0]</td>
<td>下一指令地址选择</td>
</tr>
<tr>
<td>D_branchTrue</td>
<td></td>
<td></td>
<td>是否分支信号，进入流水</td>
</tr>
<tr>
<td>F_PC</td>
<td>input</td>
<td>[31:0]</td>
<td>算NPC用</td>
</tr>
<tr>
<td>NPC</td>
<td>output</td>
<td>[31:0]</td>
<td>传给F级IFU</td>
</tr>
<tr>
<td><strong>DEReg</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E_Flush</td>
<td>input</td>
<td></td>
<td>阻塞清空DE寄存器</td>
</tr>
<tr>
<td>E_PC</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;D_PC</td>
</tr>
<tr>
<td>E_Ins</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;D_Ins</td>
</tr>
<tr>
<td>E_rs_data</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;<strong>D_rs_fw</strong></td>
</tr>
<tr>
<td>E_rt_data</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;<strong>D_rt_fw</strong></td>
</tr>
<tr>
<td>E_EXT_out</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;D_EXT_out</td>
</tr>
<tr>
<td>E_branchTrue</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;D_branchTrue</td>
</tr>
</tbody></table>
<h4 id="3-Execute"><a href="#3-Execute" class="headerlink" title="3. Execute"></a>3. Execute</h4><ul>
<li>包括E_CU, E_ALU, E_MDU, EMReg</li>
<li>需在此处多向Conflict传递MDU指令以及乘除运行信息，并向流水中传递HI, LO以便mf指令W级读取</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>E_PC</td>
<td>input</td>
<td>[31:0]</td>
<td>PC流水</td>
</tr>
<tr>
<td>E_Ins</td>
<td>input</td>
<td>[31:0]</td>
<td>指令流水</td>
</tr>
<tr>
<td><strong>Conflict&#x2F;Forward</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E_branchTrue</td>
<td>input</td>
<td></td>
<td>是否分支信号</td>
</tr>
<tr>
<td>E_Tnew</td>
<td>output</td>
<td>[1:0]</td>
<td>AT算阻塞</td>
</tr>
<tr>
<td>E_rs</td>
<td>output</td>
<td>[4:0]</td>
<td>E级指令读寄存器的编号</td>
</tr>
<tr>
<td>E_rt</td>
<td>output</td>
<td>[4:0]</td>
<td></td>
</tr>
<tr>
<td>E_rs_data</td>
<td>output</td>
<td>[31:0]</td>
<td>E级指令读寄存器原数据</td>
</tr>
<tr>
<td>E_rt_data</td>
<td>output</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>E_GRF_WA</td>
<td>output</td>
<td>[4:0]</td>
<td>E级指令写寄存器的编号</td>
</tr>
<tr>
<td>E_rs_fw</td>
<td>input</td>
<td>[31:0]</td>
<td>E级接收转发后寄存器数据</td>
</tr>
<tr>
<td>E_rt_fw</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>GRF_WDSrc</td>
<td></td>
<td>[2:0]</td>
<td>E级指令写寄存器的数据选择</td>
</tr>
<tr>
<td>E_GRF_WD</td>
<td>output</td>
<td>[31:0]</td>
<td>E级指令写寄存器的数据</td>
</tr>
<tr>
<td><strong>ALU</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E_EXT_out</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>ALUSrc</td>
<td></td>
<td></td>
<td>ALU_B数据源选择</td>
</tr>
<tr>
<td>ALUSelect</td>
<td></td>
<td>[3:0]</td>
<td>ALU功能选择</td>
</tr>
<tr>
<td>E_ALU_A</td>
<td></td>
<td>[31:0]</td>
<td>&#x3D;<strong>E_rs_fw</strong>：ALU_A口数据</td>
</tr>
<tr>
<td>E_ALU_B</td>
<td></td>
<td>[31:0]</td>
<td>&#x3D;<strong>E_rt_fw</strong>&#x2F;E_EXT_out：ALU_B口数据</td>
</tr>
<tr>
<td><strong>MDU</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>MDU</td>
<td>output</td>
<td></td>
<td>MDU指令</td>
</tr>
<tr>
<td>MDUSelect</td>
<td></td>
<td>[2:0]</td>
<td>CU给MDU的功能选择</td>
</tr>
<tr>
<td>MDUStart</td>
<td>output</td>
<td></td>
<td>MDU运算开始</td>
</tr>
<tr>
<td>MDUBusy</td>
<td>output</td>
<td></td>
<td>MDU运算进行（发给Conflict判断阻塞)</td>
</tr>
<tr>
<td>E_HI</td>
<td></td>
<td>[31:0]</td>
<td>待转发的E级MDU的HI结果</td>
</tr>
<tr>
<td>E_LO</td>
<td></td>
<td>[31:0]</td>
<td>待转发的E级MDU的LO结果</td>
</tr>
<tr>
<td><strong>EMReg</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>M_PC</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;E_PC</td>
</tr>
<tr>
<td>M_Ins</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;E_Ins</td>
</tr>
<tr>
<td>M_ALU_Y</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;E_ALU_Y</td>
</tr>
<tr>
<td>M_rt_data</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;<strong>&#x3D;E_rt_fw</strong></td>
</tr>
<tr>
<td>M_branchTrue</td>
<td>output</td>
<td>reg</td>
<td>&lt;&#x3D;E_branchTrue</td>
</tr>
<tr>
<td>M_HI</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;E_HI</td>
</tr>
<tr>
<td>M_LO</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;E_LO</td>
</tr>
</tbody></table>
<ul>
<li>#####E_ALU</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>op</td>
<td>input</td>
<td>[3:0]</td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>Y</td>
<td>output</td>
<td>[31:0]</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>#####E_MDU</p>
<ul>
<li>当指令为mthi, mtlo，将寄存器数据写入HI, LO时，始终上升沿直接给HI, LO赋为A</li>
<li>当为其余四条运算指令时，设置临时计数变量cnt，初始为0，接受到Start信号时，开始设置Busy为1；根据MDU功能选择编码，分别直接计算出HI, LO对应结果赋值，因为其他乘除操作已被阻塞，不会提前读取或写入；设置cnt为5或10，每周期-1，cnt&#x3D;&#x3D;1代表运算结束，持续保持Busy为5&#x2F;10周期后将cnt, Busy归零。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Start</td>
<td>input</td>
<td></td>
<td>CU传入开始乘除运算信号</td>
</tr>
<tr>
<td>MDUSelect</td>
<td>input</td>
<td>[2:0]</td>
<td>CU传入乘除功能选择</td>
</tr>
<tr>
<td>A</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>Busy</td>
<td>output</td>
<td>reg</td>
<td>正在运算信号</td>
</tr>
<tr>
<td>HI</td>
<td>output</td>
<td>reg [31:0]</td>
<td></td>
</tr>
<tr>
<td>LO</td>
<td>output</td>
<td>reg [31:0]</td>
<td></td>
</tr>
</tbody></table>
<h4 id="4-Memory"><a href="#4-Memory" class="headerlink" title="4. Memory"></a>4. Memory</h4><ul>
<li>包括M_CU, M_DE</li>
<li>因储存器外置，删除DM，加入对字节存取数据的操作，包括通过控制四位ByteEn各位</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>M_PC</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>M_Ins</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td><strong>Conflict&#x2F;Forward</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>M_branchTrue</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>M_Tnew</td>
<td>output</td>
<td>[1:0]</td>
<td>AT算阻塞</td>
</tr>
<tr>
<td>M_GRF_WA</td>
<td>output</td>
<td>[4:0]</td>
<td>M级指令写寄存器编号</td>
</tr>
<tr>
<td>M_GRF_WD</td>
<td>output</td>
<td>[31:0]</td>
<td>M级指令写寄存器数据</td>
</tr>
<tr>
<td>M_rt</td>
<td>output</td>
<td>[4:0]</td>
<td>M级指令读寄存器编号</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GRF_WDSrc</td>
<td></td>
<td>[2:0]</td>
<td>M级指令写寄存器数据选择</td>
</tr>
<tr>
<td>MFSelect</td>
<td></td>
<td>[1:0]</td>
<td>读HI LO功能选择</td>
</tr>
<tr>
<td>M_HI</td>
<td>input</td>
<td>[31:0]</td>
<td>待转发的E级MDU的HI结果</td>
</tr>
<tr>
<td>M_LO</td>
<td>input</td>
<td>[31:0]</td>
<td>待转发的E级MDU的LO结果</td>
</tr>
<tr>
<td>M_ALU_Y</td>
<td>input</td>
<td>[31:0]</td>
<td>待转发的E级ALU计算结果</td>
</tr>
<tr>
<td><strong>M_BE</strong>（ByteEnable）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>lowAddr</td>
<td></td>
<td>[1:0]</td>
<td>&#x3D;M_ALU_Y[1:0]，DM写入地址地两位</td>
</tr>
<tr>
<td>M_rt_fw</td>
<td>input</td>
<td>[31:0]</td>
<td>M级接收转发后将写入DM的数据</td>
</tr>
<tr>
<td>ByteSelect</td>
<td></td>
<td>[1:0]</td>
<td>CU访存数据类型选择</td>
</tr>
<tr>
<td>MemWrite</td>
<td></td>
<td></td>
<td>DM写使能</td>
</tr>
<tr>
<td>ByteEn</td>
<td>output</td>
<td>reg [3:0]</td>
<td>控制每一位是否读写的信号输出</td>
</tr>
<tr>
<td>M_DM_WD</td>
<td>output</td>
<td>reg [31:0]</td>
<td></td>
</tr>
<tr>
<td><strong>M_DE</strong>（DataExtend）</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>DESelect</td>
<td></td>
<td>[2:0]</td>
<td>字节数据拓展类型</td>
</tr>
<tr>
<td>M_DM_RDin</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>M_DM_RDout</td>
<td></td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td><strong>MWReg</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>W_PC</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;M_PC</td>
</tr>
<tr>
<td>W_Ins</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;M_Ins</td>
</tr>
<tr>
<td>W_ALU_Y</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;M_ALU_Y</td>
</tr>
<tr>
<td>W_DM_RD</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;M_DM_RDout</td>
</tr>
<tr>
<td>W_branchTrue</td>
<td>output</td>
<td>reg</td>
<td>&lt;&#x3D;M_branchTrue</td>
</tr>
<tr>
<td>W_HI</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;M_HI</td>
</tr>
<tr>
<td>W_LO</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;M_LO</td>
</tr>
</tbody></table>
<ul>
<li><h5 id="M-BE（计算字节访存使能，调整四字节写入数据）"><a href="#M-BE（计算字节访存使能，调整四字节写入数据）" class="headerlink" title="M_BE（计算字节访存使能，调整四字节写入数据）"></a>M_BE（计算字节访存使能，调整四字节写入数据）</h5><ul>
<li><p>合并在Memory中，在写入的条件下，根据写入数据类型和写入地址低两位产生四个字节的每一位控制信号，即四位ByteEn</p>
</li>
<li><p>后续再根据ByteEn调整将写入内存的数据，需将待写入的字节移动到对应为En1的位置</p>
</li>
</ul>
</li>
<li><h5 id="M-DE（调整内存读出数据，截取需要的字节后拓展）"><a href="#M-DE（调整内存读出数据，截取需要的字节后拓展）" class="headerlink" title="M_DE（调整内存读出数据，截取需要的字节后拓展）"></a>M_DE（调整内存读出数据，截取需要的字节后拓展）</h5><ul>
<li><p>注意DESelect种类编码，注意需要将读出字节移动至低位，高位进行拓展补齐</p>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>lowAddr</td>
<td>input</td>
<td>[1:0]</td>
<td></td>
</tr>
<tr>
<td>DESelect</td>
<td>input</td>
<td>[2:0]</td>
<td></td>
</tr>
<tr>
<td>in</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>out</td>
<td>output</td>
<td>[31:0]</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>M级与内存数据交换</p>
</li>
<li><img src="image-20230311001314893.png" alt="image-20230311001314893" style="zoom:67%;" /></li>
</ul>
<h4 id="5-Writeback"><a href="#5-Writeback" class="headerlink" title="5. Writeback"></a>5. Writeback</h4><ul>
<li>包括W_CU</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>W_Ins</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>W_PC</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td><strong>Conflict&#x2F;Forward</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>W_branchTrue</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>W_GRF_WA</td>
<td>output</td>
<td>[4:0]</td>
<td>W级指令写寄存器编号</td>
</tr>
<tr>
<td>GRF_WDSrc</td>
<td></td>
<td>[2:0]</td>
<td>W级指令写寄存器数据选择</td>
</tr>
<tr>
<td>MFSelect</td>
<td></td>
<td>[1:0]</td>
<td>读HI LO功能选择</td>
</tr>
<tr>
<td>W_ALU_Y</td>
<td>input</td>
<td>[31:0]</td>
<td>待转发的E级ALU计算结果</td>
</tr>
<tr>
<td>W_DM_RD</td>
<td>input</td>
<td>[31:0]</td>
<td>待转发的M级DM读出数据</td>
</tr>
<tr>
<td>W_HI</td>
<td>input</td>
<td>[31:0]</td>
<td>待转发的E级MDU的HI结果</td>
</tr>
<tr>
<td>W_LO</td>
<td>input</td>
<td>[31:0]</td>
<td>待转发的E级MDU的LO结果</td>
</tr>
<tr>
<td>W_GRF_WD</td>
<td>output</td>
<td>[31:0]</td>
<td>W级指令写寄存器数据</td>
</tr>
</tbody></table>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li>非中断异常测试同P6</li>
<li>中断测试</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text </span><br><span class="line">lui $1,0xffff</span><br><span class="line">ori $1,$1,0xfc01</span><br><span class="line">mtc0 $1,$12</span><br><span class="line">lui $2,0xffff</span><br><span class="line">#int-grf</span><br><span class="line">ori $2,$2,0x1234</span><br><span class="line">#int-store</span><br><span class="line">sw $2,0($0)</span><br><span class="line">ori $3,$0,0xfc01</span><br><span class="line">#int-mfc0</span><br><span class="line">mtc0 $3,$12</span><br><span class="line">#int-load</span><br><span class="line">lw $4,0($0)</span><br><span class="line">lw $5,0($0)</span><br><span class="line">#int-stall</span><br><span class="line">add $6,$5,$4</span><br><span class="line">lui $7,0x7fff</span><br><span class="line">lui $8,0x7fff</span><br><span class="line">#int-beq</span><br><span class="line">beq $7,$8,label1</span><br><span class="line">#int&amp;exc-BD</span><br><span class="line">add $9,$7,$8</span><br><span class="line">#int-D beq</span><br><span class="line">addi $10,$0,0x0001</span><br><span class="line">addi $11,$0,0x0002</span><br><span class="line">beq $7,$8,label1</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">label1:</span><br><span class="line">mult $7,$8</span><br><span class="line">syscall</span><br><span class="line">div $7,$8</span><br><span class="line">syscall</span><br><span class="line">mthi $7</span><br><span class="line">syscall</span><br><span class="line">mtlo $8</span><br><span class="line">syscall</span><br><span class="line">mfhi $10</span><br><span class="line">mflo $11</span><br><span class="line">mult $7,$8</span><br><span class="line">beq $7,$8,label2</span><br><span class="line">#int-many nop</span><br><span class="line">mflo $12</span><br><span class="line">addi $12,$0,0x0001</span><br><span class="line">addi $12,$0,0x0002</span><br><span class="line"></span><br><span class="line">label2:</span><br><span class="line">addi $13,$0,0x0001</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">beq $0,$0,end</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.ktext 0x4180</span><br><span class="line">main_handler:</span><br><span class="line">mfc0 $26,$13</span><br><span class="line">mfc0 $27,$14</span><br><span class="line">ori $27,$0,0x007c</span><br><span class="line">and $26,$27,$26</span><br><span class="line">beq $0,$26,interrupt</span><br><span class="line">nop</span><br><span class="line">mfc0 $26,$14</span><br><span class="line">add $26,$26,4</span><br><span class="line">mtc0 $26,$14</span><br><span class="line">beq $0,$0,return</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">interrupt:</span><br><span class="line">ori $27,$0,0x2137</span><br><span class="line">sw $27,0x7f20($0)</span><br><span class="line">beq $0,$0,return</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">return:</span><br><span class="line">eret</span><br></pre></td></tr></table></figure>
<img src="image-20230311001726074.png" alt="image-20230311001726074"/>

<ul>
<li>异常测试：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">    mtc0 $0, $12</span><br><span class="line">    ori $at, $0, 0xfffc</span><br><span class="line"></span><br><span class="line"> #====OV=====</span><br><span class="line">    lui $t0, 0x7fff</span><br><span class="line">    lui $t1, 0xffff</span><br><span class="line">    add $t2, $t0, $t1</span><br><span class="line">    sub $t2, $t0, $t1</span><br><span class="line">    sub $t2, $t1, $t0</span><br><span class="line">    lui $t1, 0x7fff</span><br><span class="line">    add $t2, $t0, $t1</span><br><span class="line">    ori $t1, $t1, 0xffff</span><br><span class="line">    addi $t2, $t1, 0xfffffff0</span><br><span class="line">    addi $t1, $t1, 0x0010</span><br><span class="line"></span><br><span class="line"> #=====SYSCALL=====</span><br><span class="line">    syscall</span><br><span class="line">    </span><br><span class="line">    #=====ADEL=====</span><br><span class="line">    lui $t1, 0x7fff</span><br><span class="line">    jal label1</span><br><span class="line">    add $ra, $ra, $t1</span><br><span class="line">label1:</span><br><span class="line">    jr $ra</span><br><span class="line">    nop</span><br><span class="line">    jal label2</span><br><span class="line">    addi $ra, $ra, 1</span><br><span class="line">label2:</span><br><span class="line">    jr $ra</span><br><span class="line">    nop</span><br><span class="line">    ori $t0, $0, 0x7f00</span><br><span class="line">    ori $t2, $0, 0x7f20</span><br><span class="line">    sw $t0, 0($0)</span><br><span class="line">    lw $t0, 0($0)</span><br><span class="line">    lw $t0, 1($0)</span><br><span class="line">    lw $t0, 2($0)</span><br><span class="line">    lh $t0, 3($0)</span><br><span class="line">    lh $t0, 0($t0)</span><br><span class="line">    lh $t0, 2($t0)</span><br><span class="line">    lb $t0, 0($t0)</span><br><span class="line">    lb $t0, 3($t0)</span><br><span class="line">loop_timer1:</span><br><span class="line">    lw $t1, 0($t0)</span><br><span class="line">    addi $t0, $t0, 4</span><br><span class="line">    bne $t0, $t2, loop_timer1</span><br><span class="line">    nop</span><br><span class="line">    ori $t0, $0, 0x3000</span><br><span class="line">    lw $t0, 0($t0)</span><br><span class="line">    lui $t0, 0x7fff</span><br><span class="line">    ori $t0, $t0, 0xffff</span><br><span class="line"> lw $t0, 1($t0)</span><br><span class="line"> lw $t0, -4($0)</span><br><span class="line"> </span><br><span class="line"> #=====ADES=====</span><br><span class="line"> sw $0, 1($0)</span><br><span class="line">    sw $0, 2($0)</span><br><span class="line">    sh $0, 3($0)</span><br><span class="line">    sw $0, 4($0)</span><br><span class="line">    sh $0, 6($0)</span><br><span class="line">    sb $0, 7($0)</span><br><span class="line">    ori $t0, $0, 0x7f00</span><br><span class="line">    sh $0, 0($t0)</span><br><span class="line">    sh $0, 2($t0)</span><br><span class="line">    sb $0, 0($t0)</span><br><span class="line">    sb $0, 3($t0)</span><br><span class="line">    ori $t1, $0, 0x7f30</span><br><span class="line">loop_timer2:</span><br><span class="line"> sw $0, 0($t0)</span><br><span class="line"> addi $t0, $t0, 4</span><br><span class="line">    bne $t0, $t1, loop_timer2</span><br><span class="line">    nop</span><br><span class="line">    ori $t0, $0, 0x3000</span><br><span class="line">    sw $0, 0($t0)</span><br><span class="line">    lui $t0, 0x7fff</span><br><span class="line">    ori $t0, $t0, 0xffff</span><br><span class="line"> sw $0, 1($t0)</span><br><span class="line"> sw $0, -1($0)</span><br><span class="line"></span><br><span class="line"> #=====ALTOGETHER=====</span><br><span class="line"> lui $t0, 0x7fff</span><br><span class="line"> ori $t1, $t0, 0xffff</span><br><span class="line"> sw $0, 0($t0)</span><br><span class="line"> addi $t1, $t1, 1</span><br><span class="line"> syscall</span><br><span class="line"> </span><br><span class="line"> sw $0, 0($t0)</span><br><span class="line"> addi $t1, $t1, 1</span><br><span class="line"> nop</span><br><span class="line"> </span><br><span class="line"> sw $0, 0($t0)</span><br><span class="line"> addi $t1, $t1, 0</span><br><span class="line"> syscall</span><br><span class="line"> </span><br><span class="line"> sw $0, 0($0)</span><br><span class="line"> addi $t1, $t1, 1</span><br><span class="line"> syscall</span><br><span class="line"> </span><br><span class="line"> lui $t0, 0x8000</span><br><span class="line"> addi $t1, $t1, 1</span><br><span class="line"> beq $t0, $t1, end</span><br><span class="line"> nop</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    beq $0, $0, end</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">.ktext 0x4180</span><br><span class="line">_main_handler:</span><br><span class="line">    mfc0 $k0, $13</span><br><span class="line">    mfc0 $k0, $14</span><br><span class="line">    and $k0, $k0, $at</span><br><span class="line">    addi $k0, $k0, 4</span><br><span class="line">    mtc0 $k0, $14</span><br><span class="line">    eret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="image-20230311001804942.png" alt="image-20230311001804942"/>

<h2 id="掉的坑"><a href="#掉的坑" class="headerlink" title="掉的坑"></a>掉的坑</h2><ul>
<li><strong>逻辑判断式中信号不可有高阻态否则出x</strong>，删除赋值逻辑时需给0，否则删除所有位置的这个信号</li>
<li>地址异常中，合法地址包括DM，TC0，TC1以及<strong>中断发生器</strong>响应地址</li>
</ul>
<img src="image-20230311001827809.png" alt="image-20230311001827809" style="zoom:80%;" />

<ul>
<li>注意出现异常或中断时，除了需要将所有级寄存器修改至即将跳转至handler的样貌之外，还需要将M级读写字节使能设为0000，防止后续指令的继续进行以及<strong>当前指令在M级对内存的写入</strong></li>
<li>注意eret与mtc0的写后读冲突，需要单独判断阻塞，判断方法为当D级为eret即将读CP0的EPC时，EM级如果有mtc0即将写入CP0的EPC，即rd为14时，阻塞。</li>
<li>宏观PC，与提供给CP0的VPC均为M级PC</li>
<li>timer中不可写count寄存器，并且只能用lw，sw进行读写</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li><p>当键盘鼠标按键时，会发出一个中断信号，经过中断控制器处理传到CPU，然后CPU根据不同的中断号执行不同的中断响应程序，然后进行相应的IO操作，如把按下的按键编码读到寄存器，执行相应功能。</p>
</li>
<li><p>为了不与正常的指令范围冲突，需要在特定地址提前放置中断处理程序并且其他指令与数据不能包含这段地址范围。用户不可自定义入口地址，因为自定义的地址上的中断处理程序可能会被其他数据覆盖。并且如果由用户提供中断异常处理程序的话，跳转的地址也是计算出来的，但是如果在计算跳转地址的时候出现了错误，异常处理就无法正常进行。</p>
</li>
<li><p>CPU外设数量可能会更多，并且是变化的，不可硬性直接相连。需要添加桥，根据读写地址或者根据外设特定信号，动态选择读写外设。</p>
</li>
<li><p>idle，load，cnt状态行为相同，只有interrupt状态控制功能不同</p>
<ol>
<li><p>idle状态下，如果计数器使能为1则转至load状态</p>
</li>
<li><p>load状态下，加载初始值之后转至cnt状态</p>
</li>
<li><p>cnt状态下，如计数器使能为1则开始倒计数，cnt&#x3D;&#x3D;0之后产生一周期终端信号，状态变为interrupt；如果计数器使能为0，则回到idle</p>
</li>
<li><p>interrupt状态下</p>
<ol>
<li>如果在模式0，计数到0时计数器使能变0，持续产生中断，变为idle状态，直到en为1，中断才清零，重新倒计时</li>
<li>如果在模式1，计数为0时中断直接变0，仅持续一个周期，但en仍为1，变为idle状态后可以自动循环继续倒计时，产生周期中断脉冲</li>
</ol>
</li>
</ol>
</li>
<li><p>倘若中断信号流入的时候，在检测宏观 PC 的一级CPU 该级所有信息均为空，则无法获得当前的PC以及当前指令是否在延迟槽中，无法获得执行完中断程序后的正确返回地址。所以清空流水线时需要保留原指令的地址以及是否处于延迟槽的信号。</p>
</li>
<li><p>Register specifiers rs and rd must not be equal, because such an instruction does not have the same effect when reexecuted. The result of executing such an instruction is UNPREDICTABLE. This restriction permits an exception handler to resume execution by re-executing the branch when an exception occurs in the branch delay slot.</p>
</li>
<li><p>指令集要求。寄存器说明符 rs 和 rd 不得相等，因为此类指令在重新执行时不具有相同的效果。执行此类指令的结果是不可预测的。此限制允许异常处理程序在分支延迟槽中发生异常时通过重新执行分支来恢复执行。</p>
</li>
</ol>
<h2 id="结算页面"><a href="#结算页面" class="headerlink" title="结算页面"></a>结算页面</h2><p>计组实验结束了，当你经历过面向对，象、操作系统、编译技术等课程的洗礼，或许你又会觉得，当年的计组是那么和蔼可亲。但请相信，没有北航人跨不过的坎”我们总要背起行囊，扬起风帆，向尽头之海进发，一往无前。</p>
<p>感谢你一路以来的不离不弃，坚守相伴，这一切的洗礼才刚刚开始，长路漫漫祝你前程似锦。</p>
<p>​                                                                                                                                                      计组课程团队<br>​                                                                                                                                                               @新北5号<br>​                                                                                                                                                               2022.12.21</p>
<img src="430ce62ac2101f40f1624ec2b8a9ef6.jpg" width="30%" />

<img src="cdf5af3d3ddb8c050cfe8e900e9345d.jpg" width="30%" />

<img src="87d0c733f6c32a8e759b783e29a9c42.jpg" width="100%" />
]]></content>
      <categories>
        <category>Computer Orgnization</category>
      </categories>
      <tags>
        <tag>Computer Orgnization</tag>
      </tags>
  </entry>
  <entry>
    <title>P5设计文档</title>
    <url>/2023/03/10/19-16-47/</url>
    <content><![CDATA[<h2 id="5级流水线CPU"><a href="#5级流水线CPU" class="headerlink" title="5级流水线CPU"></a>5级流水线CPU</h2><span id="more"></span>
<h2 id="支持指令"><a href="#支持指令" class="headerlink" title="支持指令"></a>支持指令</h2><p>add, sub, ori, lw, sw, beq, lui, j, jr, jal, nop</p>
<p>(其中add，sub为无符号加减法)</p>
<table>
<thead>
<tr>
<th>Instuction</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><em>add</em></td>
<td>GPR[rd] &#x3D; GPR[rs] + GPR[rt]</td>
</tr>
<tr>
<td><em>sub</em></td>
<td>GPR[rd] &#x3D; GPR[rs] - GPR[rt]</td>
</tr>
<tr>
<td><em>ori</em></td>
<td>GPR[rt] &#x3D;  GPR[rs] | ZeroExt(Imm)</td>
</tr>
<tr>
<td><em>lui</em></td>
<td>GPR[rt] &#x3D;  {imm, 16’b0}</td>
</tr>
<tr>
<td><em>lw</em></td>
<td>R[rt] &#x3D;  Mem[GPR[rs]+sign_ext(offset)]</td>
</tr>
<tr>
<td><em>sw</em></td>
<td>Mem[GPR[rs]+sign_ext(offset)] &#x3D; R[rt]</td>
</tr>
<tr>
<td><em>beq</em></td>
<td>if (GPR[rs] &#x3D;&#x3D;  GPR[rt])  PC &#x3D; PC + 4 + BranchAddr</td>
</tr>
<tr>
<td><em>j</em></td>
<td>PC &#x3D; JumpAddr</td>
</tr>
<tr>
<td><em>jal</em></td>
<td>PC &#x3D;  JumpAddr; GPR[31] &#x3D; PC + 4</td>
</tr>
<tr>
<td><em>jr</em></td>
<td>PC &#x3D; GPR[rs]</td>
</tr>
</tbody></table>
<h2 id="五个阶段"><a href="#五个阶段" class="headerlink" title="五个阶段"></a>五个阶段</h2><table>
<thead>
<tr>
<th>阶段</th>
<th>简称</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td>取指阶段 (Fetch)</td>
<td>F</td>
<td>从指令存储器中读取指令</td>
</tr>
<tr>
<td>译码阶段 (Decode)</td>
<td>D</td>
<td>从寄存器文件中读取源操作数并对指令译码以便得到控制信号</td>
</tr>
<tr>
<td>执行阶段 (Execute)</td>
<td>E</td>
<td>使用ALU执行计算</td>
</tr>
<tr>
<td>存储阶段 (Memory)</td>
<td>M</td>
<td>读或写数据存储器</td>
</tr>
<tr>
<td>写回阶段 (Writeback)</td>
<td>W</td>
<td>将结果写回到寄存器文件</td>
</tr>
</tbody></table>
<h2 id="关键数据通路"><a href="#关键数据通路" class="headerlink" title="关键数据通路"></a>关键数据通路</h2><p><img src="C:\Users\MGLDT\Desktop\84544e34190091ae83c43cf89ae096e.jpg" alt="84544e34190091ae83c43cf89ae096e"></p>
<h2 id="流程模块设计"><a href="#流程模块设计" class="headerlink" title="流程模块设计"></a>流程模块设计</h2><h3 id="CU模块设计"><a href="#CU模块设计" class="headerlink" title="CU模块设计"></a>CU模块设计</h3><ul>
<li>相较P4，省去RegWrite信号，直接译出当前指令需要写入的地址，如不需写入，默认写至0，在写入GRF时直接略去</li>
<li>直接译出当前指令rs, rt, rd, shamt, imm16, imm26以及所有控制信号供每个阶段选取使用，还需译出Tuse_rs&#x2F;rt以及E_Tnew与M_Tnew，各级输出对应信号至Conflict模块</li>
<li>将指令分类，分为：cal_r, cal_i, load, save, branch, shift, jreg, jadd, jlink（ori被归为cal_i）</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Ins</td>
<td>input</td>
<td>[31:0]</td>
<td>当级指令</td>
</tr>
<tr>
<td>branchTrue</td>
<td>input</td>
<td></td>
<td>分支控制信号</td>
</tr>
<tr>
<td><strong>控制信号</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>GRF_WA</td>
<td>output</td>
<td>[4:0]</td>
<td>写入的地址</td>
</tr>
<tr>
<td>GRF_WDSrc</td>
<td>output</td>
<td>[2:0]</td>
<td>写入数据选择</td>
</tr>
<tr>
<td>ALUSrc</td>
<td>output</td>
<td></td>
<td>ALU_B的数据源选择</td>
</tr>
<tr>
<td>ALUSelect</td>
<td>output</td>
<td>[2:0]</td>
<td>ALU运算类型选择</td>
</tr>
<tr>
<td>MemWrite</td>
<td>output</td>
<td></td>
<td>内存写入控制</td>
</tr>
<tr>
<td>EXTSelect</td>
<td>output</td>
<td></td>
<td>EXT位拓展类型选择</td>
</tr>
<tr>
<td>BranchSelect</td>
<td>output</td>
<td>[2:0]</td>
<td>branch判断类型选择</td>
</tr>
<tr>
<td>NPCSelect</td>
<td>output</td>
<td>[2:0]</td>
<td>NPC类型选择</td>
</tr>
<tr>
<td>ByteLW</td>
<td>output</td>
<td></td>
<td>字节写入读出控制</td>
</tr>
<tr>
<td><strong>指令译码</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>opcode</td>
<td>output</td>
<td>[5:0]</td>
<td></td>
</tr>
<tr>
<td>funct</td>
<td>output</td>
<td></td>
<td></td>
</tr>
<tr>
<td>rs</td>
<td>output</td>
<td>[4:0]</td>
<td></td>
</tr>
<tr>
<td>rt</td>
<td>output</td>
<td></td>
<td></td>
</tr>
<tr>
<td>rd</td>
<td>output</td>
<td></td>
<td></td>
</tr>
<tr>
<td>shamt</td>
<td>output</td>
<td>[4:0]</td>
<td></td>
</tr>
<tr>
<td>imm16</td>
<td>output</td>
<td>[15:0]</td>
<td></td>
</tr>
<tr>
<td>imm26</td>
<td>output</td>
<td>[25:0]</td>
<td></td>
</tr>
<tr>
<td><strong>T计算</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Tuse_rs</td>
<td>output</td>
<td>[1:0]</td>
<td></td>
</tr>
<tr>
<td>Tuse_rt</td>
<td>output</td>
<td>[1:0]</td>
<td></td>
</tr>
<tr>
<td>E_Tnew</td>
<td>output</td>
<td>[1:0]</td>
<td></td>
</tr>
<tr>
<td>M_Tnew</td>
<td>output</td>
<td>[1:0]</td>
<td></td>
</tr>
</tbody></table>
<h4 id="T计算表格"><a href="#T计算表格" class="headerlink" title="T计算表格"></a>T计算表格</h4><table>
<thead>
<tr>
<th>Ins</th>
<th></th>
<th>Tuse_rs</th>
<th>Tuse_rt</th>
<th>E_Tnew</th>
<th>M_Tnew</th>
<th>W_Tnew</th>
</tr>
</thead>
<tbody><tr>
<td>cal_r</td>
<td>add||sub</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>cal_i</td>
<td>ori||lui</td>
<td>1</td>
<td></td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>load</td>
<td>lw</td>
<td>2</td>
<td></td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>save</td>
<td>sw</td>
<td>1</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>branch</td>
<td>beq</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>jreg</td>
<td>jr</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>jadd</td>
<td>j||jal</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>jlink</td>
<td>jal</td>
<td></td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table>
<h3 id="Conflit模块设计：AT控制阻塞，直接转发"><a href="#Conflit模块设计：AT控制阻塞，直接转发" class="headerlink" title="Conflit模块设计：AT控制阻塞，直接转发"></a>Conflit模块设计：AT控制阻塞，直接转发</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul>
<li>D级判断将要使用的寄存器数据是否能得到转发更新，即后续写入相同寄存器的Tnew是否有大于Tuse的，如果有则需要阻塞，以在后续能得到转发更新。特判0号寄存器不需要阻塞，能够直接获得数据0</li>
<li>需要得到D级指令rs, rt的Tuse，以及后续E, M级指令的Tnew，在各级CU中计算，发送至冲突单元（W级Tnew全是0不需要考虑，都可以内部转发解决）</li>
<li>阻塞时需要暂停更新PC以及F级读出的指令，并且清空D级当前指令的译码输出，以替换为nop空泡</li>
</ul>
<img src="image-20230311000745591.png" alt="image-20230311000745591"/>

<h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><ul>
<li><p>阻塞后，所有指令在需要读寄存器数据的时候都能够获得后续计算完毕的数据，每级转发出已算出的数据，发送给之前各级即可。</p>
</li>
<li><p>需要读寄存器：D级GRF，Branch计算需要rs, rt数据；E级ALU需要rs,rt 数据；M级DM写入数据口需要rt数据</p>
</li>
<li><p>需要写寄存器：E级可转发出D级算的PC+8；M级可转发出D级算的PC+8和E级算的的ALU_Y；W级可转发出D级算的PC+8，E级算的的ALU_Y和M级读出的DM数据。<strong>根据当前指令CU译码得到的GRF_WDSrc进行选择</strong>。此外还有W级寄存器写入，可直接内部转发至D级读出</p>
</li>
</ul>
<img src="image-20230311000822296.png" alt="image-20230311000822296" style="zoom:67%;" />

<img src="image-20221119123512795.png" alt="image-20221119123512795" style="zoom:67%;" />

<img src="image-20221119123500142.png" alt="image-20221119123500142" style="zoom:67%;" />

<img src="image-20221119123633639.png" alt="image-20221119123633639" style="zoom:67%;" />

<ul>
<li>在主模块中，获取各级需要读的寄存器编号（D_rs,D_rt,E_rs,E_rt,M_rt），寄存器原读数（D_rs_data,D_rt_data,E_rs_data,E_rt_data,M_rt_data），写入的寄存器编号（E_GRF_WA,M_GRF_WA,W_GRF_WA）和数据（E_GRF_WD,M_GRF_WD,W_GRF_WD）</li>
<li>比较读的编号和写的编号是否有相等的，如有相等的则代表有数据已经更新需要转发，转发优先级为更新次序，最后一次更新优先转发，即优先转发距离需要数据的阶段近的数据，特判如果需要读0号寄存器的数据，直接转发0</li>
<li>转发的数据（D_rs_fw,D_rt_fw,E_rs_fw,E_rt_fw,M_rt_fw）发送至各级需要的部分运算，并传递给下一级</li>
</ul>
<img src="C:\Users\MGLDT\AppData\Roaming\Typora\typora-user-images\image-20221119122330496.png" alt="image-20221119122330496" style="zoom:67%;" />

<h3 id="五级模块设"><a href="#五级模块设" class="headerlink" title="五级模块设"></a>五级模块设</h3><ul>
<li><p>每个阶段之间以寄存器隔开，寄存器设计在每个模块输出处，使用reg类型</p>
</li>
<li><p>每个阶段之间需要流水传递Ins，PC，传给各级CU以译码出当前阶段的rs，rt以及需要写入的地址和写入数据的选择</p>
</li>
<li><p>部分阶段前后间需要传递需要使用的NPC, EXTout, ALU_Y, DM_RD</p>
</li>
</ul>
<h4 id="1-Fetch"><a href="#1-Fetch" class="headerlink" title="1. Fetch"></a>1. Fetch</h4><ul>
<li>包含F_IFU，FDReg</li>
<li>Fetch</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>F_Flush</td>
<td>input</td>
<td></td>
<td>清空延迟槽信号</td>
</tr>
<tr>
<td>F_Stall</td>
<td>input</td>
<td></td>
<td>阻塞更新PC</td>
</tr>
<tr>
<td>NPC</td>
<td>input</td>
<td>[31:0]</td>
<td>D级NPC计算出的NPC传入</td>
</tr>
<tr>
<td>F_PC</td>
<td>output</td>
<td>[31:0]</td>
<td>F级直接传给NPC的F级PC，以直接计算F_PC+4</td>
</tr>
<tr>
<td>F_Ins</td>
<td></td>
<td>[31:0]</td>
<td>指令流水</td>
</tr>
<tr>
<td><strong>FD寄存器</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>D_Stall</td>
<td>input</td>
<td></td>
<td>阻塞更新FD间寄存器</td>
</tr>
<tr>
<td>D_PC</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;F_PC</td>
</tr>
<tr>
<td>D_Ins</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;F_Ins</td>
</tr>
</tbody></table>
<ul>
<li>F_IFU</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>F_Stall</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>NPC</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>PC</td>
<td>output</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>Ins</td>
<td>output</td>
<td>[31:0]</td>
<td></td>
</tr>
</tbody></table>
<h4 id="2-Decode"><a href="#2-Decode" class="headerlink" title="2. Decode"></a>2. Decode</h4><ul>
<li>包括D_CU, EXT, NPC (Branch), DEReg</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>D_PC</td>
<td>input</td>
<td>[31:0]</td>
<td>PC流水</td>
</tr>
<tr>
<td>D_Ins</td>
<td>input</td>
<td>[31:0]</td>
<td>指令流水</td>
</tr>
<tr>
<td><strong>Conflict&#x2F;Forward</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Tuse_rs</td>
<td>output</td>
<td>[1:0]</td>
<td>AT算阻塞</td>
</tr>
<tr>
<td>Tuse_rt</td>
<td>output</td>
<td>[1:0]</td>
<td></td>
</tr>
<tr>
<td>D_rs</td>
<td>output</td>
<td>[4:0]</td>
<td>D级指令读寄存器的编号</td>
</tr>
<tr>
<td>D_rt</td>
<td>output</td>
<td>[4:0]</td>
<td></td>
</tr>
<tr>
<td>D_rs_data</td>
<td>output</td>
<td>[31:0]</td>
<td>D级指令读寄存器原数据</td>
</tr>
<tr>
<td>D_rt_data</td>
<td>output</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>D_rs_fw</td>
<td>input</td>
<td>[31:0]</td>
<td>D级转发后寄存器数据</td>
</tr>
<tr>
<td>D_rt_fw</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td><strong>EXT</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>imm16</td>
<td></td>
<td>[15:0]</td>
<td>EXT输入</td>
</tr>
<tr>
<td>EXTSelect</td>
<td></td>
<td></td>
<td>EXT功能选择</td>
</tr>
<tr>
<td>D_EXT_out</td>
<td></td>
<td>[31:0]</td>
<td>EXT输出</td>
</tr>
<tr>
<td><strong>NPC</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>NPCSelect</td>
<td></td>
<td>[2:0]</td>
<td>下一指令地址选择</td>
</tr>
<tr>
<td>branchTrue</td>
<td></td>
<td></td>
<td>是否分支信号</td>
</tr>
<tr>
<td>F_PC</td>
<td>input</td>
<td>[31:0]</td>
<td>算NPC用</td>
</tr>
<tr>
<td>NPC</td>
<td>output</td>
<td>[31:0]</td>
<td>传给F级IFU</td>
</tr>
<tr>
<td><strong>DEReg</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E_Flush</td>
<td>input</td>
<td></td>
<td>阻塞清空DE寄存器</td>
</tr>
<tr>
<td>E_PC</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;D_PC</td>
</tr>
<tr>
<td>E_Ins</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;D_Ins</td>
</tr>
<tr>
<td>E_rs_data</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;<strong>D_rs_fw</strong></td>
</tr>
<tr>
<td>E_rt_data</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;<strong>D_rt_fw</strong></td>
</tr>
<tr>
<td>E_EXT_out</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;D_EXT_out</td>
</tr>
</tbody></table>
<h4 id="3-Execute"><a href="#3-Execute" class="headerlink" title="3. Execute"></a>3. Execute</h4><ul>
<li>包括E_CU, ALU, EMReg</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>E_PC</td>
<td>input</td>
<td>[31:0]</td>
<td>PC流水</td>
</tr>
<tr>
<td>E_Ins</td>
<td>input</td>
<td>[31:0]</td>
<td>指令流水</td>
</tr>
<tr>
<td><strong>Conflict&#x2F;Forward</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E_Tnew</td>
<td>output</td>
<td>[1:0]</td>
<td>AT算阻塞</td>
</tr>
<tr>
<td>E_rs</td>
<td>output</td>
<td>[4:0]</td>
<td>E级指令读寄存器的编号</td>
</tr>
<tr>
<td>E_rt</td>
<td>output</td>
<td>[4:0]</td>
<td></td>
</tr>
<tr>
<td>E_rs_data</td>
<td>output</td>
<td>[31:0]</td>
<td>E级指令读寄存器原数据</td>
</tr>
<tr>
<td>E_rt_data</td>
<td>output</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>E_GRF_WA</td>
<td>output</td>
<td>[4:0]</td>
<td>E级指令写寄存器的编号</td>
</tr>
<tr>
<td>E_rs_fw</td>
<td>input</td>
<td>[31:0]</td>
<td>E级接收转发后寄存器数据</td>
</tr>
<tr>
<td>E_rt_fw</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>GRF_WDSrc</td>
<td></td>
<td>[2:0]</td>
<td>E级指令写寄存器的数据选择</td>
</tr>
<tr>
<td>E_GRF_WD</td>
<td>output</td>
<td>[31:0]</td>
<td>E级指令写寄存器的数据</td>
</tr>
<tr>
<td><strong>ALU</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E_EXT_out</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>ALUSrc</td>
<td></td>
<td></td>
<td>ALU_B数据源选择</td>
</tr>
<tr>
<td>ALUSelect</td>
<td></td>
<td>[2:0]</td>
<td>ALU功能选择</td>
</tr>
<tr>
<td>E_ALU_A</td>
<td></td>
<td>[31:0]</td>
<td>&#x3D;<strong>E_rs_fw</strong>：ALU_A口数据</td>
</tr>
<tr>
<td>E_ALU_B</td>
<td></td>
<td>[31:0]</td>
<td>&#x3D;<strong>E_rt_fw</strong>&#x2F;E_EXT_out：ALU_B口数据</td>
</tr>
<tr>
<td><strong>EMReg</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>M_PC</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;E_PC</td>
</tr>
<tr>
<td>M_Ins</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;E_Ins</td>
</tr>
<tr>
<td>M_ALU_Y</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;E_ALU_Y</td>
</tr>
<tr>
<td>M_rt_data</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;<strong>&#x3D;E_rt_fw</strong></td>
</tr>
</tbody></table>
<ul>
<li>E_ALU</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>op</td>
<td>input</td>
<td>[2:0]</td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>Y</td>
<td>output</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>Greater</td>
<td>output</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Equal</td>
<td>output</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Less</td>
<td>output</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="4-Memory"><a href="#4-Memory" class="headerlink" title="4. Memory"></a>4. Memory</h4><p>包括M_CU, DM</p>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>M_PC</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>M_Ins</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td><strong>Conflict&#x2F;Forward</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>M_Tnew</td>
<td>output</td>
<td>[1:0]</td>
<td>AT算阻塞</td>
</tr>
<tr>
<td>M_rt</td>
<td>output</td>
<td>[4:0]</td>
<td>M级指令读寄存器编号</td>
</tr>
<tr>
<td>M_rt_data</td>
<td>output</td>
<td>[31:0]</td>
<td>M级指令读寄存器数据</td>
</tr>
<tr>
<td>M_rt_fw</td>
<td>input</td>
<td>[31:0]</td>
<td>M级接收转发后寄存器数据</td>
</tr>
<tr>
<td>M_GRF_WA</td>
<td>output</td>
<td>[4:0]</td>
<td>M级指令写寄存器编号</td>
</tr>
<tr>
<td>GRF_WDSrc</td>
<td></td>
<td>[2:0]</td>
<td>M级指令写寄存器数据选择</td>
</tr>
<tr>
<td>M_ALU_Y</td>
<td>input</td>
<td>[31:0]</td>
<td>待转发的E级ALU计算结果</td>
</tr>
<tr>
<td>M_GRF_WD</td>
<td>output</td>
<td>[31:0]</td>
<td>M级指令写寄存器数据</td>
</tr>
<tr>
<td><strong>DM</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>MemWrite</td>
<td></td>
<td></td>
<td>DM写使能</td>
</tr>
<tr>
<td>DM_A</td>
<td></td>
<td>[31:0]</td>
<td>&#x3D;M_ALU_Y：DM读写地址</td>
</tr>
<tr>
<td>DM_WD</td>
<td></td>
<td>[31:0]</td>
<td>&#x3D;<strong>M_rt_fw</strong>：DM写入数据</td>
</tr>
<tr>
<td>DM_RD</td>
<td></td>
<td>[31:0]</td>
<td>DM读出数据</td>
</tr>
<tr>
<td><strong>MWReg</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>W_PC</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;M_PC</td>
</tr>
<tr>
<td>W_Ins</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;M_Ins</td>
</tr>
<tr>
<td>W_ALU_Y</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;M_ALU_Y</td>
</tr>
<tr>
<td>W_DM_RD</td>
<td>output</td>
<td>reg [31:0]</td>
<td>&lt;&#x3D;DM_RD</td>
</tr>
</tbody></table>
<ul>
<li>M_DM</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>WE</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ByteLW</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>WD</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>RD</td>
<td>output</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>PC</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
</tbody></table>
<h4 id="5-Writeback"><a href="#5-Writeback" class="headerlink" title="5. Writeback"></a>5. Writeback</h4><ul>
<li>包括W_CU</li>
</ul>
<table>
<thead>
<tr>
<th>Port name</th>
<th>Direction</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>clk</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reset</td>
<td>input</td>
<td></td>
<td></td>
</tr>
<tr>
<td>W_Ins</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td>W_PC</td>
<td>input</td>
<td>[31:0]</td>
<td></td>
</tr>
<tr>
<td><strong>Conflict&#x2F;Forward</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>W_GRF_WA</td>
<td>output</td>
<td>[4:0]</td>
<td>W级指令写寄存器编号</td>
</tr>
<tr>
<td>W_ALU_Y</td>
<td>input</td>
<td>[31:0]</td>
<td>待转发的E级ALU计算结果</td>
</tr>
<tr>
<td>W_DM_RD</td>
<td>input</td>
<td>[31:0]</td>
<td>待转发的M级DM读出数据</td>
</tr>
<tr>
<td>GRF_WDSrc</td>
<td></td>
<td>[2:0]</td>
<td>W级指令写寄存器数据选择</td>
</tr>
<tr>
<td>W_GRF_WD</td>
<td>output</td>
<td>[31:0]</td>
<td>W级指令写寄存器数据</td>
</tr>
</tbody></table>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li>枚举各指令排列和之间距离</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">                                        # 13</span><br><span class="line">    ori     $t0,    $0,         0xadce</span><br><span class="line">    sw      $t0,    12($0)</span><br><span class="line">    ori     $t1,    $t0,        0xdefa</span><br><span class="line">    sw      $t1,    8($0)</span><br><span class="line"></span><br><span class="line">    ori     $t3,    $0,         4</span><br><span class="line">    lw      $t2,    8($t3)</span><br><span class="line">    add     $t4,    $t2,        $t0</span><br><span class="line"></span><br><span class="line">    ori     $t3,    $0,         15</span><br><span class="line">    lw      $t4,    -7($t3)</span><br><span class="line">    sub     $t5,    $t4,        $t2</span><br><span class="line"></span><br><span class="line"># 14</span><br><span class="line">    ori     $t0,    $0,         0xefac</span><br><span class="line">    sw      $t0,    12($0)</span><br><span class="line">    ori     $t1,    $t0,        0xfead</span><br><span class="line">    sw      $t1,    8($0)</span><br><span class="line"></span><br><span class="line">    ori     $t3,    $0,         4</span><br><span class="line">    lw      $t2,    8($t3)</span><br><span class="line">    add     $t4,    $t0,        $t2</span><br><span class="line"></span><br><span class="line">    ori     $t3,    $0,         21</span><br><span class="line">    lw      $t4,    -13($t3)</span><br><span class="line">    sub     $t5,    $t2,        $t4</span><br><span class="line"></span><br><span class="line"># 15</span><br><span class="line">    ori     $t0,    $0,         0x0ace</span><br><span class="line">    sw      $t0,    12($0)</span><br><span class="line">    ori     $t1,    $t0,        0x00a1</span><br><span class="line">    sw      $t1,    8($0)</span><br><span class="line"></span><br><span class="line">    ori     $t3,    $0,         4</span><br><span class="line">    lw      $t2,    8($t3)</span><br><span class="line">    nop     </span><br><span class="line">    add     $t4,    $t2,        $t0</span><br><span class="line"></span><br><span class="line">    ori     $t3,    $0,         15</span><br><span class="line">    lw      $t4,    -7($t3)</span><br><span class="line">    nop     </span><br><span class="line">    sub     $t5,    $t4,        $t2</span><br><span class="line"></span><br><span class="line"># 16</span><br><span class="line">    lui     $t0,    0x1234</span><br><span class="line">    sw      $t0,    12($0)</span><br><span class="line">    lui     $t1,    0xfead</span><br><span class="line">    sw      $t1,    8($0)</span><br><span class="line"></span><br><span class="line">    ori     $t3,    $0,         4</span><br><span class="line">    lw      $t2,    8($t3)</span><br><span class="line">    nop     </span><br><span class="line">    add     $t4,    $t0,        $t2</span><br><span class="line"></span><br><span class="line">    ori     $t3,    $0,         25</span><br><span class="line">    lw      $t4,    -17($t3)</span><br><span class="line">    nop     </span><br><span class="line">    sub     $t5,    $t2,        $t4</span><br><span class="line"></span><br><span class="line"># 17</span><br><span class="line">    lui     $1,     0x13ac</span><br><span class="line">    ori     $2,     0x12ae</span><br><span class="line"></span><br><span class="line">    add     $3,     $1,         $2</span><br><span class="line">    ori     $4,     $3,         0xcd12</span><br><span class="line"></span><br><span class="line">    sub     $5,     $4,         $1</span><br><span class="line">    ori     $6,     $5,         0x4589</span><br><span class="line"></span><br><span class="line"># 18</span><br><span class="line">    lui     $1,     0x56ed</span><br><span class="line">    ori     $2,     0x349a</span><br><span class="line"></span><br><span class="line">    add     $3,     $1,         $2</span><br><span class="line">    nop     </span><br><span class="line">    ori     $4,     $3,         0xc102</span><br><span class="line"></span><br><span class="line">    sub     $5,     $4,         $1</span><br><span class="line">    nop     </span><br><span class="line">    ori     $6,     $5,         0x4ea9</span><br><span class="line"></span><br><span class="line"># 19</span><br><span class="line">    lui     $7,     0x1345</span><br><span class="line">    ori     $8,     $7,         0x1122</span><br><span class="line"></span><br><span class="line">    ori     $9,     $8,         0x3344</span><br><span class="line">    ori     $10,    $9,         0x00ff</span><br><span class="line"></span><br><span class="line"># 20</span><br><span class="line">    lui     $7,     0x2211</span><br><span class="line">    nop     </span><br><span class="line">    ori     $8,     $7,         0x3366</span><br><span class="line">    nop     </span><br><span class="line">    ori     $9,     $8,         0xf111</span><br><span class="line">    nop     </span><br><span class="line">    ori     $10,    $9,         0x00ff</span><br><span class="line"></span><br><span class="line"># 21</span><br><span class="line">    jal     label1</span><br><span class="line">    ori     $8,     $ra,        0x8899</span><br><span class="line">    nop     </span><br><span class="line">    nop     </span><br><span class="line">label1:</span><br><span class="line">                                        # 22</span><br><span class="line">    jal     label2</span><br><span class="line">    nop     </span><br><span class="line">    nop     </span><br><span class="line">    nop     </span><br><span class="line">    nop     </span><br><span class="line">label2:</span><br><span class="line">    ori     $9,     $ra,        0xaa12</span><br><span class="line">                                        # 23</span><br><span class="line">    ori     $t0,    $0,         35</span><br><span class="line">    sw      $ra,    24($0)</span><br><span class="line">    lw      $t1,    -11($t0)</span><br><span class="line">    ori     $t2,    $t1,        0xe2df</span><br><span class="line"></span><br><span class="line"># 24</span><br><span class="line">    sw      $t2,    36($0)</span><br><span class="line">    lw      $t3,    1($t0)</span><br><span class="line">    nop     </span><br><span class="line">    ori     $t4,    $t3,        0xaabb</span><br></pre></td></tr></table></figure>

<img src="image-20230311000946878.png" alt="image-20230311000946878"/>

<ul>
<li>对0号寄存器读些测试</li>
</ul>
<img src="image-20230311000952084.png" alt="image-20230311000952084"/>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>需要寄存器数据进行运算或是向后传递的端口需要的是接收转发后正确的数据</li>
<li>GRF不能实例化两次，数据不相通</li>
<li>读出0号寄存器时直接转发5’b00000。此时rs, rt的Tnew均为0</li>
<li>注意数据是否是直接发送，或是需要等待寄存器一个周期</li>
</ul>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>提前分支判断也代表提前需要rs, rt寄存器数据，如之前为lw指令，则可能还需阻塞一周期。指令序列：</li>
</ol>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lw </span>$<span class="built_in">t0</span>,<span class="number">0</span>($<span class="built_in">t2</span>)</span><br><span class="line"><span class="keyword">beq </span>$<span class="built_in">t0</span>,$<span class="built_in">t1</span>,<span class="number">0x3004</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>因为延迟槽在处理的时候会将跳转前的必定执行的指令放在跳转指令后一句，此时PC+4处为延迟槽指令，跳转指令下一条实际距离跳转指令8字节，返回地址需保存PC+8</li>
<li>直接从功能部件转发会导致转发与接收转发两个阶段数据通路相连，导致指令指令最短周期必须大幅增加以保证数据可以在两阶段中完整流动，降低整体执行效率</li>
<li>如没有转发，W级写入数据在上升沿才能开始写入，而读出则在上升沿瞬间已经执行，寄存器堆中数据还没有更新。实现方法为判断写入数据寄存器编号是否和读出寄存器编号相等，如相等则直接读出即将写入的数据。当寄存器为0时，直接转发0</li>
<li><ul>
<li>需求者：D级branch判断处以及NPC跳转地址处，E级ALU计算处，M级DM写入数据处</li>
<li>供给者：DEReg处写给$31的PC+8，EMReg处ALU计算结果，MW处DM读出数据</li>
</ul>
</li>
<li><ul>
<li>branch指令需要拓展输入数据来源以及branch类型，并且可能需要把是否跳转的信号传值各级CU控制是否读写和PC来源选择</li>
<li>GRF写入地址可能是寄存器读出的数据（？），可在Writeback级内部转发读出结果至写入地址</li>
<li>延迟槽可能需要清空，需要增加对FD寄存器的清空信号</li>
</ul>
</li>
<li>译码器为一个输出包含输入指令的所有控制信号，指令分解部分，写入寄存器编号，读出寄存器编号，Tuse_rs，Tuse_rt，E_Tnew和M_Tnew。通过输入的指令全部译码，各流水级分别实例化，获取所需的控制信号与数据</li>
</ol>
]]></content>
      <categories>
        <category>Computer Orgnization</category>
      </categories>
      <tags>
        <tag>Computer Orgnization</tag>
      </tags>
  </entry>
  <entry>
    <title>lab1实验报告</title>
    <url>/2023/03/10/21-48-08/</url>
    <content><![CDATA[<h2 id="lab1实验报告"><a href="#lab1实验报告" class="headerlink" title="lab1实验报告"></a>lab1实验报告</h2><span id="more"></span>

<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><h4 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h4><ul>
<li>编译程序hello.c，再用 objdump 反编译.o与可执行文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x86：</span><br><span class="line">gcc -c hello.c 生成 hello.o 文件</span><br><span class="line">gcc -o hello_x86 hello.c 链接</span><br><span class="line">objdump -DSt hello.o x86工具链反编译x86下的.o文件</span><br><span class="line">objdump -DSt hello_x86 x86工具链反编译x86下的可执行文件</span><br><span class="line">mips-linux-gnu-objdump -DSt hello.o :can<span class="string">&#x27;t disassemble for architecture UNKNOWN!  </span></span><br><span class="line"><span class="string">mips-linux-gnu-objdump -DSt hello_x86 :can&#x27;</span>t disassemble <span class="keyword">for</span> architecture UNKNOWN!</span><br><span class="line"></span><br><span class="line">=&gt;mips-linux-gnu-工具链不可反编译x86下的.o与可执行文件</span><br><span class="line"></span><br><span class="line">MIPS交叉编译工具链：</span><br><span class="line">mips-linux-gnu-gcc -c hello.c 生成 hello.o文件</span><br><span class="line">mips-linux-gnu-gcc -o hello_mips hello.o 链接</span><br><span class="line">objdump -DSt hello.o x86工具链反编译mips下的.o文件</span><br><span class="line">objdump -DSt hello_mips x86工具链反编译mips下的可执行文件</span><br><span class="line">mips-linux-gnu-objdump -DSt hello.o mips-linux-gnu-工具链工具链反编译mips下的.o文件</span><br><span class="line">mips-linux-gnu-objdump -DSt hello_mips &gt;mips-linux-gnu-工具链反编译mips下的可执行文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-D </span><br><span class="line">--disassemble-all </span><br><span class="line">与 -d 类似，但反汇编所有section.</span><br><span class="line"></span><br><span class="line">-S </span><br><span class="line">--<span class="built_in">source</span> </span><br><span class="line">尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。 </span><br><span class="line"></span><br><span class="line">-t：显示可执行文件的符号表。</span><br></pre></td></tr></table></figure>

<ul>
<li>反编译.o文件时某一些指令的地址为0，没有取得应有的地址，但在链接成为可执行文件后，则被填入地址。</li>
<li>通过观察不同工具链编译出的可执行文件和使用 objdump 解析的结果，可以发现它们在汇编指令和符号表等方面存在差异。不同的工具链可能使用不同的指令集，因此编译出的可执行文件也会有所不同。</li>
</ul>
<h4 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h4><ul>
<li>readelf解析之前在 target 目录下生成的内核 ELF 文件结果</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">0:0x0</span><br><span class="line">1:0x80400000</span><br><span class="line">2:0x80401a80</span><br><span class="line">3:0x80401a98</span><br><span class="line">4:0x80401ab0</span><br><span class="line">5:0x0</span><br><span class="line">6:0x0</span><br><span class="line">7:0x0</span><br><span class="line">8:0x0</span><br><span class="line">9:0x0</span><br><span class="line">10:0x0</span><br><span class="line">11:0x0</span><br><span class="line">12:0x0</span><br><span class="line">13:0x0</span><br><span class="line">14:0x0</span><br><span class="line">15:0x0</span><br><span class="line">16:0x0</span><br></pre></td></tr></table></figure>

<ul>
<li>使用readelf -h 得到两个文件文件头差异</li>
</ul>
<p><img src="/image-20230307161525500.png" alt="image-20230307161525500"></p>
<ul>
<li>编写的readelf中Elf32_Ehdr等针对的是32位的ELF的解析，hello程序ELF类别是32位，可被编写的readelf解析，但readelf文件本身位64位ELF，不可被解析。系统工具则都可解析</li>
</ul>
<h4 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h4><ul>
<li><p>在实验操作系统的启动过程中，有一个引导加载程序的阶段。引导加载程序位于启动入口地址处，它的作用是将内核从磁盘中加载到内存中，并将控制权转移到内核入口地址。实验操作系统的内核入口地址放置在内存布局图的正确位置时，引导加载程序可以正确地将控制权转移到内核入口地址处，进入内核。</p>
</li>
<li><p>因此，尽管内核入口地址不是启动入口地址，但通过引导加载程序的正确执行，内核入口仍然可以被正确地跳转到。</p>
</li>
</ul>
<h3 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h3><ul>
<li><p>理解整体架构，查找、理解所需内存配置信息与关联函数参数使用，如：</p>
<ul>
<li>1.1 中查找各个结构体中成员表示的含义，对应ELF文件结构。节头中的地址信息需要通过binary ELF 的文件头地址+shoff 为入口偏移+节头数*节头大小e_shentsize得到当前节头地址，再通过该节头结构体中的sh_addr得到节头中的地址信息。</li>
<li>1.4 中 printk时第三个参数传入的是unsigned long，十进制有符号数需要提前判断是否为负数，取绝对值，提出负号单独处理</li>
</ul>
</li>
<li><p>1.4中c的语法和与逻辑，一些指针的使用，以及一点点mips的语法</p>
</li>
</ul>
<h3 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h3><ul>
<li>体会到内核设计运行的复杂与严谨，内存信息需有序规划分配。以及多种类型文件的不同方式的编译，分别负责整体的不同功能方面。</li>
<li>体会到一些c语言的强大的灵活基础能力</li>
<li>记得要读网站上的题目，以及教程exercise上下文的信息提示，如“Note 1.3.5 通过查看内存布局图，同学们应该能找到.text 节的加载地址了，.data 和.bss 只需要紧随其后即可。”</li>
</ul>
]]></content>
      <categories>
        <category>Operation System</category>
      </categories>
      <tags>
        <tag>Operation System</tag>
      </tags>
  </entry>
  <entry>
    <title>lab0基础知识整理</title>
    <url>/2023/03/10/20-40-24/</url>
    <content><![CDATA[<h3 id="lab0基础知识整理"><a href="#lab0基础知识整理" class="headerlink" title="lab0基础知识整理"></a>lab0基础知识整理</h3><span id="more"></span>
<ul>
<li>一些特殊字符</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Linux——<span class="variable">$1</span>、<span class="variable">$#</span>、<span class="variable">$@</span>、<span class="variable">$0</span>、<span class="variable">$1</span>、<span class="variable">$2</span></span><br><span class="line"></span><br><span class="line">$? ——最后运行的命令的结束代码（返回值） </span><br><span class="line">$- ——使用Set命令设定的Flag一览 </span><br><span class="line">$* ——所有参数列表。如<span class="string">&quot;$*&quot;</span>用「<span class="string">&quot;」括起来的情况、以&quot;</span><span class="variable">$1</span> <span class="variable">$2</span> … <span class="variable">$n</span><span class="string">&quot;的形式输出所有参数。 </span></span><br><span class="line"><span class="string"><span class="variable">$@</span> ——所有参数列表。如&quot;</span><span class="variable">$@</span><span class="string">&quot;用「&quot;</span>」括起来的情况、以<span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="string">&quot;<span class="variable">$2</span>&quot;</span> … <span class="string">&quot;<span class="variable">$n</span>&quot;</span> 的形式输出所有参数。 </span><br><span class="line"><span class="variable">$#</span> ——添加到Shell的参数个数 </span><br><span class="line"><span class="variable">$0</span> ——Shell本身的文件名 </span><br><span class="line"><span class="variable">$1</span>～<span class="variable">$n</span> ——添加到Shell的各参数值。<span class="variable">$1</span>是第1参数、<span class="variable">$2</span>是第2参数…。 </span><br></pre></td></tr></table></figure>

<ul>
<li>变量，注意要用双引号括特殊这些字符</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">str=<span class="string">&quot;Hello, <span class="variable">$1</span> and <span class="variable">$2</span>!&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span></span><br></pre></td></tr></table></figure>

<ul>
<li>if</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> (( <span class="variable">$1</span> &gt; <span class="variable">$2</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;first &gt; second&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (( <span class="variable">$1</span> &lt; <span class="variable">$2</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;first &lt; second&quot;</span></span><br><span class="line"><span class="keyword">elif</span> (( <span class="variable">$1</span> == <span class="variable">$2</span> ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;first == second&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;I don&#x27;t know...&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<ul>
<li>赋值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a=123</span><br><span class="line">b=abc</span><br><span class="line">c=‘123’</span><br><span class="line">d=“hello world”</span><br><span class="line"></span><br><span class="line">读取终端的输入给变量赋值：<span class="built_in">read</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;Please Input your name:&quot;</span></span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hi,<span class="variable">$name</span>,welcome to uncle Jelly&#x27;s cabin!&quot;</span></span><br><span class="line">或者：<span class="built_in">read</span> -p <span class="string">&quot;Please Input your name:&quot;</span> name</span><br><span class="line"></span><br><span class="line">反引用：``，利用其他命令的输出来给一个变量赋值</span><br><span class="line"><span class="built_in">dir</span>=`<span class="built_in">pwd</span>`</span><br><span class="line">tim=`<span class="built_in">date</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;我在<span class="variable">$dir</span>目录下&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;现在时间是<span class="variable">$time</span>&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>运算</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a=2</span><br><span class="line">b=3</span><br><span class="line">c=$[a+b]</span><br><span class="line">d=$[a-b]</span><br><span class="line">g=$[a%b] </span><br><span class="line"></span><br><span class="line">c=$[<span class="variable">$a</span>+<span class="variable">$b</span>] 中括号和里面的表达式可以视作一个变量。在中括号中引用变量可以直接使用变量名，也可以使用$加变量名。</span><br><span class="line"></span><br><span class="line"><span class="built_in">expr</span>:</span><br><span class="line"></span><br><span class="line">a=2</span><br><span class="line">b=3</span><br><span class="line"><span class="built_in">expr</span> <span class="variable">$a</span> + <span class="variable">$b</span></span><br><span class="line"><span class="built_in">expr</span> <span class="variable">$a</span> % <span class="variable">$b</span>：该命令会将计算结果打印到标准输出</span><br><span class="line">将<span class="built_in">expr</span>的计算结果赋值：反引用</span><br><span class="line">c=`<span class="built_in">expr</span> <span class="variable">$a</span> + <span class="variable">$b</span>`</span><br><span class="line"></span><br><span class="line">浮点运算：bc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;45.36-22.33&#x27;</span>|bc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;scale=3;2/3&#x27;</span>|bc  .666</span><br><span class="line"></span><br><span class="line">自增自减：<span class="built_in">let</span></span><br><span class="line"><span class="built_in">let</span> a-=2</span><br><span class="line"><span class="built_in">let</span> b++</span><br></pre></td></tr></table></figure>

<ul>
<li>常用语法</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; 输出重定向，将命令标准输出保存为文件。$ <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; ./hello.txt</span><br><span class="line">&lt; 输入重定向，读取文件内容，作为标准输出。$ <span class="built_in">cat</span> &lt; ./hello.txt</span><br><span class="line">&gt;&gt; 输出重定向，将命令标准输出追加到文件。$ <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; ./hello.txt</span><br><span class="line">2&gt; 将命令执行的标准错误（stderr）保存为文件。</span><br><span class="line">2&gt;&gt; 将命令执行的标志错误（stderr）追加到文件。</span><br><span class="line">&amp;&gt; 将标准输出（stdout）和标准错误（stderr）全部保存为文件。</span><br><span class="line">1&gt;&amp;2 将标准输出发送为标准错误。</span><br><span class="line">2&gt;&amp;1 将标准错误发送为标准输出。</span><br><span class="line">| 管道，用于连续命令的执行，前面命令的输出可以传递到后面的命令作为输入。$ <span class="built_in">ls</span> -al \| grep .txt</span><br><span class="line">$ 变量符，输出变量时使用。</span><br><span class="line">$( ) 将命令的结果变量化。$ <span class="built_in">echo</span> $(data)</span><br><span class="line">` ` 将命令的结果变量化。$ <span class="built_in">echo</span> `data`</span><br><span class="line">&amp;&amp; 一行内连续执行多个命令，有错误时终止。$ make &amp;&amp; make install</span><br><span class="line">; 一行内执行多个命令，忽略错误。$ <span class="literal">false</span>; <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">’ ’ 字符串。不处理其中包含的变量。‘ ’ 中使用 “ ” 需要添加转义字符 \</span><br><span class="line">“ ” 字符串。会处理其中包含的变量。“ ” 中可以使用 ‘ ’</span><br><span class="line"><span class="variable">$&#123; &#125;</span> 1. 变量替换；2. 默认变量。</span><br><span class="line">\ 将单行命令写成多行。</span><br><span class="line">&#123;1…10&#125; 表示连续数字。</span><br><span class="line">&#123;字符串1， 字符串2&#125; 指定多个字符串。$ <span class="built_in">cp</span> ./&#123;exp1.txt,exp2.txt&#125; hello/</span><br><span class="line"><span class="keyword">if</span> 用于比较变量或字符串。<span class="keyword">if</span> [ <span class="variable">$a</span> -eq <span class="variable">$b</span> ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="variable">$a</span> <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">ls</span>) <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span> <span class="keyword">done</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">while</span> : <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span>; <span class="built_in">sleep</span>; <span class="keyword">done</span></span><br><span class="line">&lt;&lt;&lt; 将字符串发送到命令的标准输入：$ <span class="built_in">cat</span> &lt;&lt;&lt; <span class="string">&quot;User name is <span class="variable">$USER</span>&quot;</span></span><br><span class="line">&lt;&lt;<span class="string">EOF EOF</span> 将多行字符串发送到命令的标准输入</span><br><span class="line"><span class="built_in">export</span> 设置环境变量。$ <span class="built_in">export</span> &lt; 变量 &gt;=&lt; 值 &gt;</span><br><span class="line">sed 更改文件中的指定字符串。$ sed -i <span class="string">&quot;s/&lt; 待查找字符串 &gt;&lt; 替换字符串 &gt;/g&quot;</span> &lt; 文件名 </span><br></pre></td></tr></table></figure>

<ul>
<li>for, while, until, break, continue</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>:</span><br><span class="line">1.<span class="keyword">for</span> i <span class="keyword">in</span> &#123;1…10&#125; 或者 <span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1…10…2)</span><br><span class="line">2. <span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 10)或者<span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 2 10)</span><br><span class="line">3. <span class="keyword">for</span>((i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++))或者<span class="keyword">for</span>((i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i+=<span class="number">2</span>))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> ((a=<span class="number">1</span>; a&lt;=<span class="number">5</span>;a++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;外层循环为<span class="variable">$a</span>&quot;</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$a</span> -gt 2 -a <span class="variable">$a</span> -lt 4 ];<span class="keyword">then</span></span><br><span class="line">     <span class="built_in">continue</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">echo</span> $[<span class="variable">$a</span>*2]</span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>:</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">i=0</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le 10 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">    <span class="built_in">let</span> i++</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">until:</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">a=0</span><br><span class="line">until (( <span class="variable">$a</span> -gt <span class="number">10</span>))</span><br><span class="line">d0</span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">   <span class="built_in">let</span> a++</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">break</span>： 后面加数字表示跳出几层循环</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((a=<span class="number">1</span>; a&lt;=<span class="number">5</span>;a++))</span><br><span class="line"><span class="keyword">do</span>        </span><br><span class="line">    <span class="keyword">for</span> ((b=<span class="number">1</span>; b&lt;=<span class="number">5</span>;b++))</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;内循环第<span class="variable">$b</span>次&quot;</span></span><br><span class="line">        <span class="keyword">if</span> [<span class="variable">$b</span> -eq 3 ];<span class="keyword">then</span></span><br><span class="line">            <span class="built_in">break</span> 2</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>awk</p>
</li>
<li><pre><code class="bash">  awk &#39;&#123;[pattern] action&#125;&#39; &#123;filenames&#125;   # 行匹配语句 awk &#39;&#39; 只能用单引号
  <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```bash</span><br><span class="line"># 每行按空格或TAB分割，输出文本中的<span class="number">1</span>、<span class="number">4</span>项</span><br><span class="line"> $ awk <span class="string">&#x27;&#123;print $1,$4&#125;&#x27;</span> <span class="keyword">log</span>.txt</span><br><span class="line"> <span class="comment">---------------------------------------------</span></span><br><span class="line"> <span class="number">2</span> a</span><br><span class="line"> <span class="number">3</span> <span class="keyword">like</span></span><br><span class="line"> This<span class="string">&#x27;s</span></span><br><span class="line"><span class="string"> 10 orange,apple,mongo</span></span><br><span class="line"><span class="string"> # 格式化输出</span></span><br><span class="line"><span class="string"> $ awk &#x27;</span>&#123;printf &quot;%-8s %-10s\n&quot;,<span class="meta">$1</span>,<span class="meta">$4</span>&#125;<span class="string">&#x27; log.txt</span></span><br><span class="line"><span class="string"> ---------------------------------------------</span></span><br><span class="line"><span class="string"> 2        a</span></span><br><span class="line"><span class="string"> 3        like</span></span><br><span class="line"><span class="string"> This&#x27;</span>s</span><br><span class="line"> <span class="number">10</span>       orange,apple,mongo</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="bash">  awk -F  #-F相当于内置变量FS, 指定分割字符
  <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```bash</span><br><span class="line"># 或者使用内建变量</span><br><span class="line"> $ awk <span class="string">&#x27;BEGIN&#123;FS=&quot;,&quot;&#125; &#123;print $1,$2&#125;&#x27;</span>     <span class="keyword">log</span>.txt</span><br><span class="line"> <span class="comment">---------------------------------------------</span></span><br><span class="line"> <span class="number">2</span> this <span class="keyword">is</span> a test</span><br><span class="line"> <span class="number">3</span> <span class="keyword">Do</span> you <span class="keyword">like</span> awk</span><br><span class="line"> This<span class="string">&#x27;s a test</span></span><br><span class="line"><span class="string"> 10 There are orange apple</span></span><br><span class="line"><span class="string"> # 使用多个分隔符.先使用空格分割，然后对分割结果再使用&quot;,&quot;分割</span></span><br><span class="line"><span class="string"> $ awk -F &#x27;</span>[ ,]<span class="string">&#x27;  &#x27;</span>&#123;print <span class="meta">$1</span>,<span class="meta">$2</span>,<span class="meta">$5</span>&#125;<span class="string">&#x27;   log.txt</span></span><br><span class="line"><span class="string"> ---------------------------------------------</span></span><br><span class="line"><span class="string"> 2 this test</span></span><br><span class="line"><span class="string"> 3 Are awk</span></span><br><span class="line"><span class="string"> This&#x27;</span>s a</span><br><span class="line"> <span class="number">10</span> There apple</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="bash">  awk -v  # 设置变量
  <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```bash</span><br><span class="line"> $ awk <span class="attribute">-va</span>=1 <span class="attribute">-vb</span>=s <span class="string">&#x27;&#123;print $1,$1+a,$1b&#125;&#x27;</span> log.txt</span><br><span class="line"> ---------------------------------------------</span><br><span class="line"> 2 3 2s</span><br><span class="line"> 3 4 3s</span><br><span class="line"> This<span class="string">&#x27;s 1 This&#x27;</span>ss</span><br><span class="line"> 10 11 10s</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>条件输出</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;$1&gt;2&#x27;</span> log.txt</span><br><span class="line">$ awk -F: <span class="string">&#x27;$3 + $4 &gt; 2000&#123;print $0&#125;&#x27;</span> /etc/passwd</span><br><span class="line">$ awk -F: <span class="string">&#x27;$3 + $4 &gt; 2000 &amp;&amp; $3 * $4 &gt; 2000&#123;print $0&#125;&#x27;</span> /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出第二列包含 &quot;th&quot;，并打印第二列与第四列</span></span><br><span class="line">$ awk <span class="string">&#x27;$2 ~ /th/ &#123;print $2,$4&#125;&#x27;</span> log.txt</span><br><span class="line">---------------------------------------------</span><br><span class="line">this a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出包含 &quot;re&quot; 的行</span></span><br><span class="line">$ awk <span class="string">&#x27;/re/ &#x27;</span> log.txt</span><br><span class="line">---------------------------------------------</span><br><span class="line">3 Do you like awk</span><br><span class="line">10 There are orange,apple,mongo</span><br><span class="line"></span><br><span class="line">格式化打印:</span><br><span class="line">$ awk -F: <span class="string">&#x27;BEGIN&#123;OFS=&quot; | &quot;&#125;&#123;printf &quot;|%+15s|%-15s|\n&quot;, $NF, $1&#125;&#x27;</span> /etc/passwd</span><br><span class="line">|  : 以 | 为分隔符</span><br><span class="line">|%+15s|  : 以 | 为分隔符 %s 配合 <span class="built_in">printf</span> 使用 代替当前字符串 右对齐 占用15字符</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Operation System</category>
      </categories>
      <tags>
        <tag>Operation System</tag>
      </tags>
  </entry>
  <entry>
    <title>lab0实验报告</title>
    <url>/2023/03/10/20-40-25/</url>
    <content><![CDATA[<h2 id="lab0实验报告"><a href="#lab0实验报告" class="headerlink" title="lab0实验报告"></a>lab0实验报告</h2><span id="more"></span>

<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><h4 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h4><ul>
<li>Untracked.txt:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">位于分支 lab0</span><br><span class="line">您的分支与上游分支 &#x27;origin/lab0&#x27; 一致。</span><br><span class="line"></span><br><span class="line">未跟踪的文件:</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 以包含要提交的内容）</span><br><span class="line">        README.txt</span><br><span class="line">        Untracked.txt</span><br><span class="line"></span><br><span class="line">提交为空，但是存在尚未跟踪的文件（使用 &quot;git add&quot; 建立跟踪）</span><br></pre></td></tr></table></figure>

<ul>
<li>Stage.txt:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">位于分支 lab0</span><br><span class="line">您的分支与上游分支 &#x27;origin/lab0&#x27; 一致。</span><br><span class="line"></span><br><span class="line">要提交的变更：</span><br><span class="line">  （使用 &quot;git restore --staged &lt;文件&gt;...&quot; 以取消暂存）</span><br><span class="line">        新文件：   README.txt</span><br><span class="line">        新文件：   Untracked.txt</span><br><span class="line"></span><br><span class="line">未跟踪的文件:</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 以包含要提交的内容）</span><br><span class="line">        Stage.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>Modified.txt:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">位于分支 lab0</span><br><span class="line">您的分支领先 &#x27;origin/lab0&#x27; 共 1 个提交。</span><br><span class="line">  （使用 &quot;git push&quot; 来发布您的本地提交）</span><br><span class="line"></span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class="line">  （使用 &quot;git restore &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class="line">        修改：     README.txt</span><br><span class="line"></span><br><span class="line">未跟踪的文件:</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 以包含要提交的内容）</span><br><span class="line">        Modified.txt</span><br><span class="line">        Stage.txt</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）</span><br></pre></td></tr></table></figure>

<ul>
<li>从Untracked到Stage，README文件从未跟踪的文件变成要提交的文件，因为使用了git add进行跟踪，提交一次本地变更之后，再修改README时，README不再是像第一次status中有一个新的没有跟踪的文件，而是有一个持续跟踪的发生变化的文件，所以两次status不一样。</li>
</ul>
<h4 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h4><ul>
<li><p>add the file: git add &lt;file&gt;</p>
</li>
<li><p>stage the file: add &lt;file&gt;</p>
</li>
<li><p>commit: git commit -m message</p>
</li>
</ul>
<h4 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h4><ol>
<li><p>git checkout – printf.c<br>  checkout两种用法：切换分支，撤销修改（暂存区 -&gt; 工作区）</p>
</li>
<li><p>git reset –hard HEAD &#x2F; git reset HEAD printf.c + git restore –staged printf.c</p>
</li>
</ol>
<p>  回退版本（仓库提交版本 -&gt; 暂存区&#x2F;工作区）</p>
<h4 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h4><ul>
<li><p>有三次提交</p>
</li>
<li><pre><code class="git">  commit ca2fac3c015bd8aded736d5f8e28a52cbc4d5bb5 (HEAD -&gt; lab0)
  Author: 王子腾 &lt;21373237@buaa.edu.cn&gt;
  Date:   Thu Mar 2 11:38:26 2023 +0800
  
      3
  
  commit ecc063e495bc4ec11d625f120d85e845d63a42a8
  Author: 王子腾 &lt;21373237@buaa.edu.cn&gt;
  Date:   Thu Mar 2 11:37:42 2023 +0800
  
      2
  
  commit c074c71ca4b2cb3b327c77807964fcc65c48ddc9
  Author: 王子腾 &lt;21373237@buaa.edu.cn&gt;
  Date:   Thu Mar 2 11:36:29 2023 +0800
  
   1
  <figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 执行命令 git <span class="built_in">reset</span> --hard HEAD^后，<span class="built_in">log</span>中最上一条说明为<span class="number">3</span>的提交消失</span><br><span class="line"></span><br><span class="line">- 找到提交说明为 <span class="number">1</span> 的哈希值，执行命令 git <span class="built_in">reset</span> --hard  后，<span class="built_in">log</span>中说明为<span class="number">2</span>的提交消失</span><br><span class="line"></span><br><span class="line">- 再使用说明为<span class="number">3</span>的哈希值，执行git <span class="built_in">reset</span> --hard ca2fac3c015bd8aded736d5f8e28a52cbc4d5bb5 之后，直接回到那一次提交</span><br><span class="line"></span><br><span class="line">#### Thinking <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">- echo <span class="built_in">first</span>: 终端输出</span><br><span class="line"></span><br><span class="line">    ```txt</span><br><span class="line">    <span class="built_in">first</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>echo second &gt; output.txt: output中内容为</p>
  <figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">second</span><br></pre></td></tr></table></figure>
</li>
<li><p>echo third &gt; output.txt: output中内容为</p>
  <figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">third</span><br></pre></td></tr></table></figure>
</li>
<li><p>echo forth &gt;&gt; output.txt: output中内容为</p>
  <figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">third</span><br><span class="line">forth</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h4><ul>
<li>command</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;echo Shell Start... </span></span><br><span class="line"><span class="string">echo set a = 1</span></span><br><span class="line"><span class="string">a=1</span></span><br><span class="line"><span class="string">echo set b = 2</span></span><br><span class="line"><span class="string">b=2</span></span><br><span class="line"><span class="string">echo set c = a+b</span></span><br><span class="line"><span class="string">c=\$[\$a+\$b]</span></span><br><span class="line"><span class="string">echo c = \$c</span></span><br><span class="line"><span class="string">echo save c to ./file1</span></span><br><span class="line"><span class="string">echo \$c&gt;file1</span></span><br><span class="line"><span class="string">echo save b to ./file2</span></span><br><span class="line"><span class="string">echo \$b&gt;file2</span></span><br><span class="line"><span class="string">echo save a to ./file3</span></span><br><span class="line"><span class="string">echo \$a&gt;file3</span></span><br><span class="line"><span class="string">echo save file1 file2 file3 to file4</span></span><br><span class="line"><span class="string">cat file1&gt;file4</span></span><br><span class="line"><span class="string">cat file2&gt;&gt;file4</span></span><br><span class="line"><span class="string">cat file3&gt;&gt;file4</span></span><br><span class="line"><span class="string">echo save file4 to ./result</span></span><br><span class="line"><span class="string">cat file4&gt;&gt;result&quot;</span> &gt;&gt; <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<ul>
<li>result</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<ul>
<li><p>a&#x3D;1, b&#x3D;2, c&#x3D;$[$a+$b]使得c&#x3D;3。c,b,a三个进入file1,2,3，最后依次存入file4，再存到result</p>
</li>
<li><p>执行<code>echo echo Shell Start</code> 与 <code>echo &#39;echo Shell Start&#39;</code>没有区别</p>
</li>
<li><p>执行<code>echo echo $c&gt;file1</code> 与 <code>echo &#39;echo $c&#39;&gt;file1</code>有区别，不加引号时，$c被认为是一个变量，但找不到值，没有显示。加引号时引号内整体被认定为字符串，全部写入file1</p>
</li>
</ul>
<h3 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h3><ul>
<li><p>引号，小括号，中括号语法混乱，Exercise 0.4中替换语句中不可用‘ ’，只能用“ ”，因为单引号直接输出内部字符串，不解析特殊字符；双引号内则会解析特殊字符</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&quot;s/<span class="variable">$2</span>/<span class="variable">$3</span>/g&quot;</span> <span class="variable">$1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Exercise 0.3中while循环[]或者(())表示条件，do done为while循环区间。分支语法if elif与最后的fi结尾。</p>
</li>
<li><p>参数运算语法，写自增</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a=$[<span class="variable">$b</span>+<span class="variable">$c</span>] </span><br><span class="line">c=<span class="string">&quot;expr <span class="variable">$a</span>+<span class="variable">$b</span>&quot;</span></span><br><span class="line"><span class="built_in">let</span> a++ </span><br><span class="line"><span class="built_in">let</span> a+=1 </span><br><span class="line">((a++))</span><br><span class="line">[ <span class="string">&quot;<span class="variable">$a</span>&quot;</span>  \&lt;  <span class="string">&quot;<span class="variable">$b</span>&quot;</span> ] 要带转义，条件表达式要放在方括号之间，并且要有空格，必须写成 [ <span class="variable">$a</span> == <span class="variable">$b</span> ]</span><br><span class="line">在[]中使用的比较符：</span><br><span class="line"> -eq                 =</span><br><span class="line"> -ne                 != </span><br><span class="line"> -gt                 &gt;  </span><br><span class="line"> -ge                 &gt;= </span><br><span class="line"> -lt                 &lt;  </span><br><span class="line"> -le                 &lt;= </span><br></pre></td></tr></table></figure>
</li>
<li><p>Exercise 0.3中根据awk语法需要临时创建一个文件保存待更改格式的内容（？</p>
</li>
<li><p>Exercise 0.4中的.c与.h文件分别存放在两个文件夹，在链接的时候需要用-I给gcc起始搜索目录</p>
</li>
<li><p>Exercise 0.4中的外层make调用内层make时</p>
</li>
</ul>
<h3 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h3><p>Linux下的各种功能更为清晰直接，提供了更多可设定参数，可以灵活编程用多种方法达到目的，并且借助一些正则表达式可以编写高效脚本。但同时大量功能和参数也使初期编写时记不清可用的功能和对应语法，导致没有头绪和大量bug…</p>
]]></content>
      <categories>
        <category>Operation System</category>
      </categories>
      <tags>
        <tag>Operation System</tag>
      </tags>
  </entry>
  <entry>
    <title>Positive Psychology P2</title>
    <url>/2023/03/11/00-46-52/</url>
    <content><![CDATA[<h2 id="Positive-Psychology-P2"><a href="#Positive-Psychology-P2" class="headerlink" title="Positive Psychology P2"></a>Positive Psychology P2</h2><span id="more"></span>

<h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><h3 id="Premise-of-the-course"><a href="#Premise-of-the-course" class="headerlink" title="Premise of the course"></a>Premise of the course</h3><ol>
<li>Bridge building (between school and society)</li>
<li>Change is possible (how)</li>
<li>Internal factors are more important (our own perception to the world)</li>
<li>Human nature needs to be obeyed</li>
<li>Happiness is a moral claim, but not the end</li>
</ol>
<ul>
<li><p>Democratizing excellence: Studying the best then applying it to the rest of us</p>
</li>
<li><p>Small group of persons can have great influence The power of one</p>
</li>
<li><p>Changes being from them, then spread, expand (connection between people)<br>Assimilate</p>
</li>
<li><p>Human network, Exponential growth-&gt; often underestimate</p>
</li>
<li><p>Smiles are contagious</p>
</li>
<li><p>Change -&gt; which direction?</p>
</li>
</ul>
<h4 id="Premise-3-internal-factors-vs-external-factors"><a href="#Premise-3-internal-factors-vs-external-factors" class="headerlink" title="Premise 3. internal factors vs. external factors"></a>Premise 3. internal factors vs. external factors</h4><ul>
<li><p>Difficult to change based on external factors</p>
</li>
<li><p>(objective measure method &#x3D; subjective) valuable √</p>
</li>
<li><p>Ecstatic</p>
</li>
<li><p>Tenure or other great gain &#x2F; loss, the happiness level goes back to their base level 6 month later (when beyond the basic needs) &#x3D;&gt; External fact makes a little difference (except some extreme circumstance like democracy and oppression, homeless…)</p>
</li>
<li><p>Lower the expectation isn’t effective in long term (problem isn’t the level, but the right&#x2F;wrong expectation)</p>
</li>
<li><p><strong>Our status of mind</strong></p>
</li>
<li><p>Transformation</p>
</li>
</ul>
<h4 id="Premise-4-the-most-important"><a href="#Premise-4-the-most-important" class="headerlink" title="Premise 4. (the most important)"></a>Premise 4. (the most important)</h4><ul>
<li><p>Human nature: change &#x2F; obey</p>
</li>
<li><p>Constrained &#x2F; not constrained human nature</p>
<ul>
<li>Constrained: Human nature can’t be changed, flaws are inevitable. accept and channel them towards the good using political institution (capitalism)</li>
<li>Unconstrainted: have solution to the flaws, can be perfected. Goal: to change our nature to better it. (communism)</li>
<li>In this course: constrained -&gt; Understand, then make the best use: channel the nature.</li>
</ul>
</li>
<li><p><strong>Topic: The permission to be human</strong></p>
</li>
<li><p>The most important pillar of wellbeing and happiness</p>
</li>
<li><p>Constantly high ×</p>
</li>
<li><p>The freedom to experience these painful emotion (refusal)</p>
<ul>
<li>New born baby √</li>
</ul>
</li>
<li><p>Façade become important, being valued constantly ×</p>
</li>
<li><p>Pay a lot of prices (energy level, wellbeing, happiness, success)</p>
</li>
<li><p>Need a space where we give ourselves the permission to be human.<br>Unconditional acceptance</p>
</li>
<li><p>Envy the baby, enjoy and celebrate the same time</p>
<ul>
<li>Paradox of being the human,</li>
</ul>
</li>
<li><p>Suppress a natural phenomenon, just intensify it (</p>
<ul>
<li>Paradoxical intension</li>
</ul>
</li>
<li><p>Accept the law of gravity -&gt; rely on it and make creation</p>
</li>
<li><p>Painful emotion &#x3D; human nature &#x3D; physical nature</p>
</li>
<li><p>Has to obey the law of nature</p>
</li>
<li><p>Great deception (how are you doing)</p>
<ul>
<li>Something wrong with us if we show the real poor feeling</li>
</ul>
</li>
<li><p>Great depression</p>
</li>
<li><p>a space where we give ourselves the permission to be human: with our friends, family and ourselves</p>
</li>
<li><p>not resignation, but active acceptance: some cannot, but some can and ought to be changed</p>
</li>
<li><p><strong>ABC</strong></p>
<ul>
<li>Affect – emotion</li>
<li>Behavior – action</li>
<li>Cognition - thoughts</li>
</ul>
</li>
<li><p>“Negative” emotions are our nature, are neutral</p>
</li>
<li><p>Envy, but choose to be generously and benevolently</p>
</li>
<li><p>Cognitively refine</p>
</li>
<li><p>Be true to the reality</p>
</li>
<li><p>Reality psychology</p>
</li>
<li><p>Psycho immune systems get stronger when we give ourselves the permission to be human</p>
<ul>
<li>Recover from the painful emotions</li>
</ul>
</li>
<li><p>Visceral emotional level: the really means of giving ourselves the permission to be human?</p>
</li>
<li><p>Just breath, and accept and ignore all the thoughts</p>
<ul>
<li>Only experiencing the life</li>
</ul>
</li>
<li><p><strong>Give ourselves and others the permission.</strong></p>
</li>
</ul>
<h3 id="Response-paper"><a href="#Response-paper" class="headerlink" title="Response paper"></a>Response paper</h3><p>As a living creature, the most basic need is being balanced. Everything should be controlled in a normal range using the negative feedback regulation, our emotion and our nature included. It may cause some inevitable flaw and create some paradox on a higher level, but “It’s a good sign of being normal rather than being dead or a psychopath”.<br>Just imagine that if we never felt lazy, we might work all the week constantly and died in fatigue. Actually, keeping excitement using some drugs isn’t a new thing and they often have terrible consequences. We are not robots.<br>However, many of us may blame ourselves for not keep staying in the best condition, like feeling a strong regret when the day is over and we return to the dormitory and think that I have wasted such a lot of time on entertainments or trivial matters and I have to get a high efficiency and achieve a lot tomorrow with determination almost every day.<br>It’s because lazy is one of our own natural flaws. Our total attention and energy are limited and maybe we can only stay highly focus in 5 hours or less. The constant and regretting thought of exceed our limits is often vain and only cost us a lot of prices like energy level, happiness and leave us with more pressure and depression.<br>But it’s not the excuse of giving up ourselves and having no control on anything. Actually, during holidays, if we keep being lazy and only have entertainments like playing games and watching TV series all day long, we may get tired and bored soon. The leisure seems to become a tight job. It seems paradoxical but it’s our nature keeping ourselves balanced.<br>Our flaws in our nature are also part of us, they keep us to be “normal” and alive. So, obey the law of nature “is not resignation, but active acceptance”. It’s about “giving ourselves the permission to be human” and having confidence in accepting the whole self. Based on this premise, our goal should be “channeling the nature” to “make the best use of them” and doing our best in every condition. We should be recognizing that some cannot, but some can and ought to be changed.<br>…<br>（channel: “Envy, but choose to be generously and benevolently”, motivate you to strive…）</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>Positive Psychology</tag>
      </tags>
  </entry>
  <entry>
    <title>Positive Psychology P3</title>
    <url>/2023/03/11/00-46-53/</url>
    <content><![CDATA[<h2 id="Positive-Psychology-P3"><a href="#Positive-Psychology-P3" class="headerlink" title="Positive Psychology P3"></a>Positive Psychology P3</h2><span id="more"></span>

<h3 id="Premise-3-internal-factors-vs-external-factors"><a href="#Premise-3-internal-factors-vs-external-factors" class="headerlink" title="Premise 3. internal factors vs. external factors"></a>Premise 3. internal factors vs. external factors</h3><p>Happiness is a moral claim, but not the end</p>
<h4 id="Controversial-issue-Happiness-is-important-But-is-it-ought-to-be-important"><a href="#Controversial-issue-Happiness-is-important-But-is-it-ought-to-be-important" class="headerlink" title="Controversial issue: Happiness is important. But is it ought to be important?"></a>Controversial issue: Happiness is important. But is it ought to be important?</h4><ol>
<li><p>States the opinions of the two sides and give their arguments mentioned by the professor or thought of by yourself.</p>
</li>
<li><p>List the examples being used.</p>
</li>
</ol>
<ul>
<li><p>Happiness</p>
<ul>
<li>The final end</li>
<li>Very purpose, very motion of our life.</li>
<li>Gain, keep, recover -&gt; secret motive</li>
</ul>
</li>
<li><p>Why should we have happiness as our <strong>highest</strong> end?</p>
<ul>
<li>Moral dimention? other improtant things?</li>
</ul>
</li>
<li><p>What’s good?</p>
<ol>
<li>It feels good to feel good. (law of identity) Need no justification</li>
<li>Contribute to our life, relationship and other people.</li>
<li>Evolutionary reason<ol>
<li>think beyond what we are thinking right now. creatitive</li>
<li>Building capacity (0-&gt;+)</li>
</ol>
</li>
</ol>
<ul>
<li>Negative emotions, our consciousness is narrowed and constricted. We are not able to think beyond what we are thinking right now. -&gt; further negative emotions. <strong>vicious cycle</strong>, cause depression.</li>
<li>Positive emotions: borden and build -&gt; further positive emotions. <strong>upward spiral</strong>.</li>
<li>How to take us from the downward to the upward: right time, the permission to be human.</li>
<li>Approach rather than running away</li>
<li>physical health</li>
</ul>
</li>
<li><p>Examples</p>
<ol>
<li>Internists facing hard problems<ol>
<li>Just think about the problems</li>
<li>Given a statement about the humanistic value</li>
<li>Candy, funny, playful mood -&gt; <strong>Better solutions</strong></li>
<li>Children learning</li>
</ol>
</li>
<li>Think back to experience that make them smile -&gt; <strong>better learning</strong><ol>
<li>Control group</li>
</ol>
</li>
</ol>
</li>
</ul>
<h4 id="Rebuttal-Is-the-pursuit-of-personal-happiness-selfish-hence-immoral"><a href="#Rebuttal-Is-the-pursuit-of-personal-happiness-selfish-hence-immoral" class="headerlink" title="Rebuttal: Is the pursuit of personal happiness selfish, hence immoral ?"></a>Rebuttal: Is the pursuit of personal happiness selfish, hence immoral ?</h4><ol>
<li><p>Arguments that prove the pursuit is moral.</p>
</li>
<li><p>What is the good nature that the professor suggests to appreciate in this part?</p>
</li>
<li><p>What is the teaching of the story of Mahatma Gandhi?</p>
</li>
<li><p>Do five extra good things and report them in class next week.</p>
</li>
</ol>
<ul>
<li><p>Pursuit of personal happiness is selfish “<strong>I</strong> want to …”</p>
</li>
<li><p><strong>selfishness &#x3D;&#x3D; immorality</strong> -&gt; No.1 cause of unhappiness</p>
</li>
<li><p><strong>Wrong</strong></p>
<ul>
<li>happiness is a positive sum game. Contagious. is a moral state that can contribute to other’s happiness</li>
<li>Happiness is tied to others. Better relationships, torlerant others</li>
</ul>
</li>
<li><p><strong>Appriciate</strong> this wonderful part of our nature (Appreciate: thanks&#x2F;increase in value)</p>
</li>
<li><p>A boy eat too many candy, his mom want Gandhi to teach him a lesson. Gandhi said: “I will teach him a lesson, but not the one you want. I will teach him to appreciate the sweetness of candy.”</p>
</li>
<li><p>Be the change you want to see in the world.</p>
</li>
<li><p>People do what you do not what you say -&gt; Spreading happiness: work on your own happiness first. (Be the example)</p>
</li>
<li><p><strong>Expand on these, apply them to our life</strong></p>
</li>
</ul>
<h3 id="Belief-as-Self-Fulfilling-Prophecy"><a href="#Belief-as-Self-Fulfilling-Prophecy" class="headerlink" title="Belief as Self-Fulfilling Prophecy"></a>Belief as Self-Fulfilling Prophecy</h3><ol>
<li><p>Elaborate with good logic and reasons why the story of Roger Bannister proves belief shapes reality.</p>
</li>
<li><p>Retell the story of Pygmalion and summarize the key of Pygmalion effect?</p>
</li>
<li><p>What condition makes the “fast spurters”experiment more convincing?</p>
</li>
</ol>
<ul>
<li>the power of the mind<ul>
<li>Roger Bannister</li>
<li>4 min per mile, the limit of human body according to experts</li>
<li>Bannister believed he could do it, he did it 1954</li>
<li>Break down the mental barrier (<strong>Potential</strong>)</li>
<li>(How belief shape reality?)</li>
<li>(How to enhance the belief? self-efficacy, self-esteem)</li>
<li>“We are what we think, all that we are arises with our thoughts, with our thoughts we make the world.” - Buddha</li>
</ul>
</li>
</ul>
<h4 id="S4"><a href="#S4" class="headerlink" title="S4"></a>S4</h4><ol>
<li><p>List the examples of negative situations created by researchers and retell at least one of them.</p>
</li>
<li><p>list the examples of positive situations created by researchers and retell at least one of them.</p>
</li>
<li><p>What condition can you make in our class?</p>
</li>
</ol>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>Positive Psychology</tag>
      </tags>
  </entry>
  <entry>
    <title>DeepLearning 1</title>
    <url>/2023/03/11/11-52-15/</url>
    <content><![CDATA[<h2 id="神经网络基础笔记-1"><a href="#神经网络基础笔记-1" class="headerlink" title="神经网络基础笔记 1"></a>神经网络基础笔记 1</h2><span id="more"></span>

<h2 id="线性神经网路"><a href="#线性神经网路" class="headerlink" title="线性神经网路"></a>线性神经网路</h2><h3 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h3><ul>
<li>处理高维数据集用向量、矩阵形式 -&gt; 矢量化代码</li>
</ul>
<p>$$<br>\hat{y} &#x3D; w_1 x_1 + … + w_d x_d + b.<br>$$ </p>
<p>$$<br>\hat{y} &#x3D; \mathbf{w}^\top \mathbf{x} + b.<br>$$</p>
<ul>
<li>w, b 为模型参数</li>
<li><code>y</code>和<code>X</code>有观测误差，引入噪声项，服从正态分布</li>
<li>是输入特征的一个 仿射变换，加系数和常数的线性变换</li>
</ul>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><ul>
<li>对拟合程度的度量，表现实际值和预测值之间的差距</li>
<li>最常用的损失函数是平方误差函数</li>
</ul>
<p>$$<br>l^{(i)}(\mathbf{w}, b) &#x3D; \frac{1}{2} \left(\hat{y}^{(i)} - y^{(i)}\right)^2.<br>$$</p>
<ul>
<li>损失函数求导&#x3D;0可求损失极小点，得到解析解</li>
</ul>
<h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><ul>
<li>无法得到解析解时，可通过梯度下降的方法优化（通用），通过不断地在损失函数递减的方向上更新参数来降低误差</li>
<li>简单用法：计算损失函数（所有样本的损失均值） 关于模型参数的导数（梯度）。但需要遍历数据集，通常随机抽取一部分样本计算，称为小批量随机梯度下降</li>
<li>步骤：<ul>
<li>初始化模型参数的值，如随机初始化</li>
<li>随机抽样小批量固定数量的训练样本$\mathcal{B}$</li>
<li>计算平均损失关于模型参数的梯度</li>
<li>我们将梯度乘以一个预先确定的正数$\alpha$为学习率，并从当前参数的值中减掉，即在负梯度的方向上更新参数，学习率表示更新移动的步长</li>
</ul>
</li>
</ul>
<p>$$<br>(\mathbf{w},b) \leftarrow (\mathbf{w},b) - \frac{\alpha}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{(\mathbf{w},b)} l^{(i)}(\mathbf{w},b).<br>$$</p>
<h3 id="似然估计法"><a href="#似然估计法" class="headerlink" title="似然估计法"></a>似然估计法</h3><ul>
<li>观测中包含噪声，其中噪声服从正态分布，可以写出通过给定的$x$观测到特定$y$的似然</li>
</ul>
<p>$$<br>P(y \mid \mathbf{x}) &#x3D; \frac{1}{\sqrt{2 \pi \sigma^2}} \exp\left(-\frac{1}{2 \sigma^2} (y - \mathbf{w}^\top \mathbf{x} - b)^2\right).<br>$$</p>
<p>根据极大似然估计法，参数$w$和$b$的最优值是使整个数据集的似然最大的值：</p>
<p>$$<br>P(\mathbf y \mid \mathbf X) &#x3D; \prod_{i&#x3D;1}^{n} p(y^{(i)}|\mathbf{x}^{(i)}).<br>$$</p>
<h3 id="SoftMax回归"><a href="#SoftMax回归" class="headerlink" title="SoftMax回归"></a>SoftMax回归</h3><ul>
<li>图像分类，编码标签作为数据，一个类别作为一个输出，一个特征作为一个输入，共n(输入)*n(输出)个权重参数</li>
<li>如三个输出，四个输入的三个未规范化的预测</li>
</ul>
<p>$$<br>\begin{split}\begin{aligned}<br>o_1 &amp;&#x3D; x_1 w_{11} + x_2 w_{12} + x_3 w_{13} + x_4 w_{14} + b_1,\\<br>o_2 &amp;&#x3D; x_1 w_{21} + x_2 w_{22} + x_3 w_{23} + x_4 w_{24} + b_2,\\<br>o_3 &amp;&#x3D; x_1 w_{31} + x_2 w_{32} + x_3 w_{33} + x_4 w_{34} + b_3.<br>\end{aligned}\end{split}<br>$$</p>
<ul>
<li>能够将未规范化的预测o变换为非负数并且总和为1，同时让模型保持可导的性质。</li>
</ul>
<p>$$<br>\hat{\mathbf{y}} &#x3D; \mathrm{softmax}(\mathbf{o})\quad \text{其中}\quad \hat{y}_j &#x3D; \frac{\exp(o_j)}{\sum_k \exp(o_k)}<br>$$</p>
<ul>
<li>参数过多，平衡开销和模型有效性: d个输入q个输出成本减小到 O(dq&#x2F;n),n为超参数</li>
<li>SoftMax及其导数</li>
</ul>
<p>$$<br>\begin{split}\begin{aligned}<br>l(\mathbf{y}, \hat{\mathbf{y}}) &amp;&#x3D;  - \sum_{j&#x3D;1}^q y_j \log \frac{\exp(o_j)}{\sum_{k&#x3D;1}^q \exp(o_k)} \\<br>&amp;&#x3D; \sum_{j&#x3D;1}^q y_j \log \sum_{k&#x3D;1}^q \exp(o_k) - \sum_{j&#x3D;1}^q y_j o_j \\<br>&amp;&#x3D; \log \sum_{k&#x3D;1}^q \exp(o_k) - \sum_{j&#x3D;1}^q y_j o_j.<br>\end{aligned}\end{split}<br>$$</p>
<p>$$<br>\partial_{o_j} l(\mathbf{y}, \hat{\mathbf{y}}) &#x3D; \frac{\exp(o_j)}{\sum_{k&#x3D;1}^q \exp(o_k)} - y_j &#x3D; \mathrm{softmax}(\mathbf{o})_j - y_j.<br>$$</p>
<h3 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h3><ul>
<li>量化数据中的信息内容：$H[P] &#x3D; \sum_j - P(j) \log P(j).$</li>
<li>交叉熵损失：所有标签分布的预期损失值</li>
<li>信息熵：不能完全预测每一个事件，用信息量$\log \frac{1}{P(j)} &#x3D; -\log P(j)$来量化预测失败的惊异程度</li>
<li>交叉熵：H(P, Q)</li>
</ul>
<h2 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h2><h3 id="隐藏层"><a href="#隐藏层" class="headerlink" title="隐藏层"></a>隐藏层</h3><ul>
<li>克服线性模型的限制</li>
<li>将许多全连接层堆叠在一起</li>
<li>在仿射变换之后对每个隐藏单元应用非线性的<em>激活函数</em>$\sigma$，避免多层感知机退化成线性模型</li>
</ul>
<p>$$<br>\begin{split}\begin{aligned}<br>    \mathbf{H} &amp; &#x3D; \sigma(\mathbf{X} \mathbf{W}^{(1)} + \mathbf{b}^{(1)}), \\<br>    \mathbf{O} &amp; &#x3D; \mathbf{H}\mathbf{W}^{(2)} + \mathbf{b}^{(2)}.\\<br>\end{aligned}\end{split}<br>$$</p>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><ul>
<li><p>ReLU函数，修正线性单元 ，要么让参数消失，要么让参数通过</p>
<p>  $$<br>  \operatorname{ReLU}(x) &#x3D; \max(x, 0)<br>  $$</p>
</li>
<li><p>sigmoid函数，将输入变换为区间(0, 1)上的输出，<em>挤压函数</em> ，是一个平滑的、可微的阈值单元近似<br>  $$<br>  \operatorname{sigmoid}(x) &#x3D; \frac{1}{1 + \exp(-x)}<br>  $$</p>
</li>
<li><p>tanh函数，将其输入压缩转换到区间(-1, 1)</p>
</li>
</ul>
<p>$$<br>\operatorname{tanh}(x) &#x3D; \frac{1 - \exp(-2x)}{1 + \exp(-2x)}.<br>$$</p>
<img src="https://img-blog.csdnimg.cn/2021010408011163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzAzODc1Mg==,size_16,color_FFFFFF,t_70" alt="2层3*3卷积核替换1个5*5的卷积核">

]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>Positive Psychology P1</title>
    <url>/2023/03/10/22-50-28/</url>
    <content><![CDATA[<h2 id="Positive-Psychology-P1"><a href="#Positive-Psychology-P1" class="headerlink" title="Positive Psychology P1"></a>Positive Psychology P1</h2><span id="more"></span>

<h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><ul>
<li><p>Shift the pendulum slightly, reasons:</p>
<ul>
<li>Questions matter.<ul>
<li>Focus on what works! Focus on our strength.</li>
<li>Positive questions -&gt; new possibilities, find potential.</li>
</ul>
</li>
</ul>
</li>
<li><p>Happiness doesn’t spontaneously arise when take unhappiness away. (Not sufficient)</p>
<ul>
<li><p><strong>Mainly focus on the health model, the source of health (to thrive, not just getting rid of unhappiness)</strong></p>
<ul>
<li>Disease model &lt;&#x3D;0</li>
<li>Work on the positive, go beyond 0</li>
</ul>
</li>
<li><p>Comfortably numb ☹ -&gt; find a flow, pursue happiness, find excitement,</p>
</li>
</ul>
</li>
<li><p>0-&gt; positive, help us deal with depression. Happy restrain unhappy</p>
</li>
<li><p>Not have a quest on getting rid of depression, but on pursuing happy.</p>
</li>
<li><p>Set root and focus on the lack of positive factor.</p>
</li>
<li><p>Like the pandemic</p>
<ul>
<li><p>The youth, less health problem, stronger physical immune system not directly on treating the illness, but keep healthy, and recover naturally.</p>
</li>
<li><p>The elderly, on the opposite, they have more problem and can’t recover and need to treat directly.</p>
</li>
</ul>
</li>
<li><p><strong>Cultivate capacity -&gt; to deal with inevitable problem</strong></p>
</li>
<li><p>Identify who we really are, what we are able to do and what we really like.</p>
</li>
</ul>
<h3 id="Premise-of-the-course"><a href="#Premise-of-the-course" class="headerlink" title="Premise of the course"></a>Premise of the course</h3><p><strong>1.</strong>   <strong>Bridge building (between school and society)</strong></p>
<p><strong>2.</strong>   <strong>Change is possible (how)</strong></p>
<p><strong>3.</strong>   <strong>Internal factors are more important (our own perception to the world)</strong></p>
<p><strong>4.</strong>   <strong>Human nature needs to be obeyed</strong></p>
<p><strong>5.</strong>   <strong>Happiness is a moral claim, but not the end</strong></p>
<h4 id="Bridge-building"><a href="#Bridge-building" class="headerlink" title="Bridge building"></a>Bridge building</h4><ul>
<li><p>Interact with the world. The academic and research need to combine with the “filthy” experience</p>
</li>
<li><p>Sense of mission, change the world better.</p>
</li>
<li><p>Not just ME, money, prestige, honor… … but the society, devote money and time. (Donation and voluntary activity)</p>
</li>
<li><p>Self-fulfilling prophecy</p>
</li>
<li><p>Susceptible</p>
</li>
<li><p>Idealism and good intention on trying to resolve the conflict are not enough,</p>
</li>
<li><p>(May ignore the problem)</p>
</li>
<li><p>Merge the <strong>research</strong> and the <strong>practice</strong>.</p>
</li>
</ul>
<h4 id="Change-is-possible"><a href="#Change-is-possible" class="headerlink" title="Change is possible"></a>Change is possible</h4><ul>
<li><p>How much do gene matter (research)</p>
</li>
<li><p>Have experience, evidence -&gt; <strong>whether to how</strong></p>
</li>
<li><p>Error of the average -&gt; Study the best (possibly the best -&gt; realize the potential)</p>
</li>
<li><p>Precious experience</p>
</li>
<li><p>Do the best</p>
</li>
</ul>
<hr>
<h2 id="Response-paper"><a href="#Response-paper" class="headerlink" title="Response paper"></a>Response paper</h2><h3 id="Go-for-Possibly-the-Best"><a href="#Go-for-Possibly-the-Best" class="headerlink" title="Go for Possibly the Best"></a>Go for Possibly the Best</h3><p>In this lesson, the professor first provided three reasons why we should shift the pendulum slightly to positive psychology research. After that, he set five premises of the course: “bridge building, change is possible, internal factors are more important, human nature needs to be obeyed, and happiness is a moral claim, but not the end.”</p>
<p>The point “change is possible” is a critical premise of having positive psychology, which is generated from discarding the “error of the average” and “studying the best”. It switches the question of whether it’s possible to change to how to change for the better and gives researchers and patients a strong belief.</p>
<p>First, the subpoint of studying the best means a lot. Humans are not like rigid physics models but have enormous differences in lots of aspects. When facing a problem, the average situation is plain and normally can’t provide a solution, but the best shows the potential and possibility and contains valuable experience and information.</p>
<p>When we know something can work, a positive perception and an ultimate goal are shown. There must be some reasons behind the special situation. So, the question we ask should focus on what factor we lack to achieve the best situation that works. While the passive questions on dealing with problems can only make the negative score go up to zero, the positive questions can make it rise up to the max positive number. The strong determination to realize the potential is crucial in achieving a better outcome, when we dedicate our best, the best situation may not be random ever.</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>Positive Psychology</tag>
      </tags>
  </entry>
</search>
